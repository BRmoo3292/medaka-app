<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>„É°„ÉÄ„Ç´„ÅÆË¶≥ÂØü„Å®‰ºöË©±</title>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      overflow-x: hidden;
    }
    
    .container {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    
    h1 {
      font-size: 1.5rem;
      margin: 10px 0;
      text-align: center;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .display-section {
      width: 100%;
      max-width: 400px;
      margin-bottom: 10px;
    }
    
    .view-container {
      position: relative;
      width: 100%;
    }
    
    #video, #displayCanvas {
      width: 100%;
      height: auto;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      background: rgba(0,0,0,0.5);
    }
    
    #displayCanvas {
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    
    #displayCanvas:active {
      transform: scale(0.98);
    }
    
    .fullscreen-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      border-radius: 20px;
      padding: 8px 12px;
      font-size: 12px;
      cursor: pointer;
      z-index: 10;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
    }
    
    .fullscreen-button:hover {
      background: rgba(0,0,0,0.9);
      transform: scale(1.05);
    }
    
    .switch-button {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      border-radius: 20px;
      padding: 8px 12px;
      font-size: 12px;
      cursor: pointer;
      z-index: 10;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
    }
    
    .switch-button:hover {
      background: rgba(0,0,0,0.9);
      transform: scale(1.05);
    }
    
    .switch-button:active {
      transform: scale(0.95);
    }
    
    .fullscreen-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    
    .fullscreen-canvas {
      max-width: 100vw;
      max-height: 80vh;
      object-fit: contain;
    }
    
    .fullscreen-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 1001;
    }
    
    .control-button {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: none;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      backdrop-filter: blur(10px);
    }
    
    .exit-button {
      background: linear-gradient(135deg, #2c2c54, #40407a);
      color: white;
      font-size: 18px;
    }
    
    .control-button:active {
      transform: scale(0.9);
    }
    
    @keyframes pulse {
      0% { 
        transform: scale(1); 
        box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.7);
      }
      50% { 
        transform: scale(1.05); 
        box-shadow: 0 0 20px 10px rgba(255, 107, 107, 0);
      }
      100% { 
        transform: scale(1); 
        box-shadow: 0 0 0 0 rgba(255, 107, 107, 0);
      }
    }
    
    .status-section {
      width: 100%;
      max-width: 400px;
      text-align: center;
      margin: 15px 0;
    }
    
    #status {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      border: 1px solid rgba(255,255,255,0.2);
      transition: all 0.3s ease;
    }
    
    #status.recording {
      background: linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(238, 90, 36, 0.3));
      animation: pulse 1.5s infinite;
    }
    
    #startButton {
      background: linear-gradient(135deg, #4facfe, #00f2fe);
      color: white;
      border: none;
      border-radius: 25px;
      padding: 15px 30px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(79, 172, 254, 0.4);
      transition: all 0.3s ease;
      margin-top: 20px;
    }
    
    #startButton:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(79, 172, 254, 0.6);
    }
    
    #startButton:active {
      transform: translateY(0);
    }
    
    .vad-controls {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      justify-content: center;
    }
    
    .vad-button {
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
    }
    
    .vad-start-button {
      background: linear-gradient(135deg, #11998e, #38ef7d);
      color: white;
    }
    
    .vad-start-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(17, 153, 142, 0.4);
    }
    
    .vad-stop-button {
      background: linear-gradient(135deg, #ff6b6b, #ee5a24);
      color: white;
    }
    
    .vad-stop-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }
    
    .hidden {
      display: none !important;
    }
    
    @media (max-width: 768px) {
      .container {
        padding: 5px;
      }
      
      h1 {
        font-size: 1.3rem;
        margin: 5px 0;
      }
      
      .display-section,
      .status-section {
        max-width: 95vw;
      }
      
      .fullscreen-controls {
        bottom: 30px;
      }
      
      .control-button {
        width: 60px;
        height: 60px;
        font-size: 20px;
      }
    }
  </style>
  <!-- ONNX Runtime Web -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>„É°„ÉÄ„Ç´„Å´„ÅäË©±„Åó„Åó„Å¶„Å≠ÔºÅ</h1>
    
    <div class="display-section">
      <div class="view-container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="displayCanvas" class="hidden"></canvas>
        <button class="fullscreen-button" id="canvasFullscreenBtn">üîç Êã°Â§ß</button>
        <button class="switch-button" id="switchViewBtn">üìä Ëß£ÊûêÁµêÊûú</button>
      </div>
    </div>
    
    <div class="status-section">
      <div id="status">üé§ Èü≥Â£∞ÂÖ•Âäõ ÂæÖÊ©ü‰∏≠...</div>
      
      <div class="vad-controls hidden" id="vadControls">
        <button class="vad-button vad-start-button" id="vadStartBtn">üé§ Èü≥Â£∞Ê§úÂá∫ÈñãÂßã</button>
        <button class="vad-button vad-stop-button" id="vadStopBtn">‚èπÔ∏è Èü≥Â£∞Ê§úÂá∫ÂÅúÊ≠¢</button>
      </div>
      
      <button id="startButton">üöÄ ‰ºöË©±„ÇíÂßã„ÇÅ„Çã</button>
    </div>
  </div>
  
  <div class="fullscreen-container hidden" id="fullscreenContainer">
    <canvas id="fullscreenCanvas"></canvas>
    <div class="fullscreen-controls">
      <button class="control-button exit-button" id="exitBtn">‚úï</button>
    </div>
  </div>
  
  <audio id="replyAudio" autoplay></audio>
  
  <script>
// Ë®≠ÂÆö„ÉªÂÆöÊï∞
const CONFIG = {
    SERVER_URL: window.location.origin,
    FRAME_RATE: 100,
    PROFILE_ID: 1
};

// DOMË¶ÅÁ¥†„ÅÆÂèñÂæó
const elements = {
    video: document.getElementById('video'),
    displayCanvas: document.getElementById('displayCanvas'),
    fullscreenCanvas: document.getElementById('fullscreenCanvas'),
    replyAudio: document.getElementById("replyAudio"),
    statusDiv: document.getElementById("status"),
    canvasFullscreenBtn: document.getElementById("canvasFullscreenBtn"),
    fullscreenContainer: document.getElementById("fullscreenContainer"),
    startButton: document.getElementById("startButton"),
    vadControls: document.getElementById("vadControls"),
    vadStartBtn: document.getElementById("vadStartBtn"),
    vadStopBtn: document.getElementById("vadStopBtn"),
    exitBtn: document.getElementById("exitBtn"),
    switchViewBtn: document.getElementById("switchViewBtn")
};
const displayCtx = elements.displayCanvas.getContext('2d');
const fullscreenCtx = elements.fullscreenCanvas.getContext('2d');

// „Ç∞„É≠„Éº„Éê„É´Áä∂ÊÖãÁÆ°ÁêÜ
const appState = {
    isFullscreen: false,
    currentImageData: null,
    isRecording: false,
    shouldRestart: true,
    isSending: false,
    ws: null,
    wsConnected: false,
    showingAnalysis: false
};

// „Éñ„É©„Ç¶„Ç∂Áâ©‰ΩìÊ§úÂá∫„É¢„Ç∏„É•„Éº„É´
const browserDetectionModule = {
    session: null,
    modelLoaded: false,
    inputSize: 640, 

    async loadModel() {
        try {
            console.log('[„Éñ„É©„Ç¶„Ç∂Ê§úÂá∫] „É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÈñãÂßã...');
            
            const modelUrl = `${window.location.origin}/best.onnx`;
            console.log('[„É¢„Éá„É´URL]', modelUrl);
            
            const sessionOptions = {
                executionProviders: ['wasm'],
                graphOptimizationLevel: 'all',
                enableCpuMemArena: false,
                enableMemPattern: false,
                logSeverityLevel: 3
            };
            
            console.log('[„É¢„Éá„É´] „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÈñãÂßã...');
            const response = await fetch(modelUrl, {
                method: 'GET',
                mode: 'cors',
                cache: 'default',
                credentials: 'omit'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const arrayBuffer = await response.arrayBuffer();
            console.log(`[„É¢„Éá„É´] „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂÆå‰∫Ü: ${arrayBuffer.byteLength} bytes`);
            
            this.session = await ort.InferenceSession.create(arrayBuffer, sessionOptions);
            
            this.modelLoaded = true;
            console.log('‚úÖ [„Éñ„É©„Ç¶„Ç∂Ê§úÂá∫] „É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
            elements.statusDiv.textContent = "‚úÖ Ê§úÂá∫„É¢„Éá„É´Ê∫ñÂÇôÂÆå‰∫Ü";
            
        } catch (error) {
            this.modelLoaded = false;
            console.error('‚ùå [„Éñ„É©„Ç¶„Ç∂Ê§úÂá∫] „É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÂ§±Êïó:', error);
            elements.statusDiv.textContent = "‚ö†Ô∏è „É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÂ§±Êïó";
        }
    },

    async detectObjects(videoElement) {
        if (!this.modelLoaded) {
            return [];
        }

        const startTime = performance.now();
        
        try {
            const inputTensor = await this.preprocessImage(videoElement);
            
            const results = await this.session.run({ images: inputTensor });
            const inferenceTime = performance.now() - startTime;
            
            console.log(`[„Éñ„É©„Ç¶„Ç∂Ê§úÂá∫] Êé®Ë´ñÊôÇÈñì: ${inferenceTime.toFixed(1)}ms`);
            
            const detections = this.postprocess(results, videoElement);
            
            return detections;
            
        } catch (error) {
            console.error('[„Éñ„É©„Ç¶„Ç∂Ê§úÂá∫] Ê§úÂá∫„Ç®„É©„Éº:', error);
            return [];
        }
    },

    async preprocessImage(videoElement) {
        const canvas = document.createElement('canvas');
        canvas.width = this.inputSize;
        canvas.height = this.inputSize;
        const ctx = canvas.getContext('2d');
        
        ctx.drawImage(videoElement, 0, 0, this.inputSize, this.inputSize);
        
        const imageData = ctx.getImageData(0, 0, this.inputSize, this.inputSize);
        const pixels = imageData.data;
        
        const red = new Float32Array(this.inputSize * this.inputSize);
        const green = new Float32Array(this.inputSize * this.inputSize);
        const blue = new Float32Array(this.inputSize * this.inputSize);
        
        for (let i = 0; i < pixels.length; i += 4) {
            const idx = i / 4;
            red[idx] = pixels[i] / 255.0;
            green[idx] = pixels[i + 1] / 255.0;
            blue[idx] = pixels[i + 2] / 255.0;
        }
        
        const input = new Float32Array(3 * this.inputSize * this.inputSize);
        input.set(red, 0);
        input.set(green, this.inputSize * this.inputSize);
        input.set(blue, 2 * this.inputSize * this.inputSize);
        
        return new ort.Tensor('float32', input, [1, 3, this.inputSize, this.inputSize]);
    },

    // ‚úÖ postprocess „ÇíÂÆåÂÖ®‰øÆÊ≠£ÔºàYOLOv8ÂΩ¢ÂºèÂØæÂøúÔºâ
    postprocess(results, videoElement) {
        const output = results.output0;
        const outputData = output.data;
        const [batchSize, numClasses, numBoxes] = output.dims;
        
        console.log(`[ÂæåÂá¶ÁêÜ] Âá∫ÂäõÂΩ¢Áä∂: [${output.dims.join(', ')}]`);
        
        const detections = [];
        const confThreshold = 0.5;  // ‚úÖ ÈñæÂÄ§„Çí‰∏ã„Åí„ÇãÔºà0.5 ‚Üí 0.3Ôºâ
        
        const scaleX = videoElement.videoWidth / this.inputSize;
        const scaleY = videoElement.videoHeight / this.inputSize;
        
        // YOLOv8„ÅÆÂá∫ÂäõÂΩ¢Âºè: [1, 5, 8400]
        // 5 = [cx, cy, w, h, confidence]
        for (let i = 0; i < numBoxes; i++) {
            const cx = outputData[i];
            const cy = outputData[numBoxes + i];
            const w = outputData[2 * numBoxes + i];
            const h = outputData[3 * numBoxes + i];
            const confidence = outputData[4 * numBoxes + i];
            
            if (confidence > confThreshold) {
                // Â∫ßÊ®ô„ÇíÂÖÉ„ÅÆÁîªÂÉè„Çµ„Ç§„Ç∫„Å´Â§âÊèõ
                const x = (cx - w / 2) * scaleX;
                const y = (cy - h / 2) * scaleY;
                const width = w * scaleX;
                const height = h * scaleY;
                
                detections.push({
                    x: Math.max(0, x),
                    y: Math.max(0, y),
                    width: Math.min(width, videoElement.videoWidth - x),
                    height: Math.min(height, videoElement.videoHeight - y),
                    confidence: confidence,
                    class: 0
                });
            }
        }
        
        // NMSÈÅ©Áî®
        const filteredDetections = this.applyNMS(detections, 0.45);
        
        console.log(`[ÂæåÂá¶ÁêÜ] Ê§úÂá∫Êï∞: ${filteredDetections.length}`);
        return filteredDetections;
    },

    applyNMS(boxes, iouThreshold) {
        if (boxes.length === 0) return [];
        
        boxes.sort((a, b) => b.confidence - a.confidence);
        
        const selected = [];
        const suppressed = new Set();
        
        for (let i = 0; i < boxes.length; i++) {
            if (suppressed.has(i)) continue;
            
            selected.push(boxes[i]);
            
            for (let j = i + 1; j < boxes.length; j++) {
                if (suppressed.has(j)) continue;
                
                const iou = this.calculateIoU(boxes[i], boxes[j]);
                if (iou > iouThreshold) {
                    suppressed.add(j);
                }
            }
        }
        
        return selected;
    },

    calculateIoU(box1, box2) {
        const x1 = Math.max(box1.x, box2.x);
        const y1 = Math.max(box1.y, box2.y);
        const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
        const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
        
        const intersectionArea = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        const box1Area = box1.width * box1.height;
        const box2Area = box2.width * box2.height;
        const unionArea = box1Area + box2Area - intersectionArea;
        
        return intersectionArea / unionArea;
    },

    drawDetections(canvas, detections) {
        const ctx = canvas.getContext('2d');
        
        detections.forEach((det, index) => {
            // „Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(det.x, det.y, det.width, det.height);
            
            // „É©„Éô„É´
            const label = `„É°„ÉÄ„Ç´${index + 1}: ${(det.confidence * 100).toFixed(0)}%`;
            
            ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
            const textWidth = ctx.measureText(label).width;
            ctx.fillRect(det.x, det.y - 25, textWidth + 20, 25);
            
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label, det.x + 5, det.y - 7);
        });
    }
};// „Ç´„É°„É©Ê©üËÉΩ
const cameraModule = {
    async startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    facingMode: "environment",
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            });
            elements.video.srcObject = stream;
        } catch (err) {
            elements.statusDiv.textContent = '‚ö†Ô∏è „Ç´„É°„É©„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÅåÊãíÂê¶„Åï„Çå„Åæ„Åó„Åü';
            console.error('Camera error:', err);
        }
    }
};

const medakaVitalityModule = {
    // ËøΩË∑°„Éá„Éº„Çø
    trackHistory: new Map(),
    speedHistory: [],
    maxHistoryLength: 75,
    fps: 15,
    
    // ÂÖÉÊ∞óÂ∫¶Âà§ÂÆö„ÅÆÈñæÂÄ§Ôºà„Éî„ÇØ„Çª„É´/ÁßíÔºâ
    thresholds: {
        veryActive: 50,
        active: 20,
        slow: 5,
        lethargic: 0
    },
    
    lastFrameTime: null,
    
    update(detections) {
        const currentTime = performance.now();
        
        // FPSË®àÁÆó
        if (this.lastFrameTime) {
            const deltaTime = (currentTime - this.lastFrameTime) / 1000;
            this.fps = 1 / deltaTime;
        }
        this.lastFrameTime = currentTime;
        
        // ÂêÑ„É°„ÉÄ„Ç´„ÅÆÈÄüÂ∫¶„ÇíË®àÁÆó
        detections.forEach((det, index) => {
            const medakaId = index;
            const currentPos = { x: det.x + det.width / 2, y: det.y + det.height / 2 };
            
            const speed = this.calculateSpeed(medakaId, currentPos);
            
            if (speed !== null) {
                this.speedHistory.push(speed);
                
                if (this.speedHistory.length > this.maxHistoryLength) {
                    this.speedHistory.shift();
                }
            }
            
            if (!this.trackHistory.has(medakaId)) {
                this.trackHistory.set(medakaId, []);
            }
            const history = this.trackHistory.get(medakaId);
            history.push({ pos: currentPos, time: currentTime });
            
            if (history.length > 10) {
                history.shift();
            }
        });
        
        const vitality = this.calculateVitality();
        this.logVitalityInfo(vitality, detections.length);
        
        return vitality;
    },
    
    calculateSpeed(medakaId, currentPos) {
        const history = this.trackHistory.get(medakaId);
        
        if (!history || history.length < 2) {
            return null;
        }
        
        const prevData = history[history.length - 1];
        const prevPos = prevData.pos;
        const prevTime = prevData.time;
        
        const distance = Math.sqrt(
            Math.pow(currentPos.x - prevPos.x, 2) + 
            Math.pow(currentPos.y - prevPos.y, 2)
        );
        
        const deltaTime = (performance.now() - prevTime) / 1000;
        
        if (deltaTime === 0) return null;
        
        const speed = distance / deltaTime;
        
        return speed;
    },
    
    calculateVitality() {
        if (this.speedHistory.length === 0) {
            return {
                status: "Unknown",
                statusJa: "‰∏çÊòé",
                avgSpeed: 0,
                score: 0,
                color: "#999999",
                dataPoints: 0
            };
        }
        
        const avgSpeed = this.speedHistory.reduce((sum, s) => sum + s, 0) / this.speedHistory.length;
        
        let status, statusJa, score, color;
        
        if (avgSpeed >= this.thresholds.veryActive) {
            status = "Active";
            statusJa = "ÂÖÉÊ∞ó";
            score = 100;
            color = "#00ff00";
        } else if (avgSpeed >= this.thresholds.active) {
            status = "Normal";
            statusJa = "ÊôÆÈÄö";
            score = 70;
            color = "#ffff00";
        } else if (avgSpeed >= this.thresholds.slow) {
            status = "Slow";
            statusJa = "„ÇÑ„ÇÑÂÖÉÊ∞ó„Åå„Å™„ÅÑ";
            score = 40;
            color = "#ff9900";
        } else {
            status = "Lethargic";
            statusJa = "„Åª„Å®„Çì„Å©Âãï„Åã„Å™„ÅÑ";
            score = 10;
            color = "#ff0000";
        }
        
        return {
            status,
            statusJa,
            avgSpeed: avgSpeed.toFixed(2),
            score,
            color,
            dataPoints: this.speedHistory.length
        };
    },
    
    logVitalityInfo(vitality, detectionCount) {
        if (this.speedHistory.length > 0 && this.speedHistory.length % 15 === 0) {
            console.log("\n" + "=".repeat(50));
            console.log("üêü „É°„ÉÄ„Ç´ÂÖÉÊ∞óÂ∫¶ÂàÜÊûê");
            console.log("=".repeat(50));
            console.log(`Ê§úÂá∫Êï∞: ${detectionCount} Âåπ`);
            console.log(`Âπ≥ÂùáÈÄüÂ∫¶: ${vitality.avgSpeed} px/Áßí`);
            console.log(`ÂÖÉÊ∞óÂ∫¶: ${vitality.statusJa} (${vitality.score}/100)`);
            console.log(`„Éá„Éº„Çø„Éù„Ç§„É≥„Éà: ${vitality.dataPoints}/${this.maxHistoryLength}`);
            console.log(`ÂÆüÂäπFPS: ${this.fps.toFixed(1)}`);
            console.log("=".repeat(50) + "\n");
        }
    },
    
    async sendVitalityToServer(vitality) {
        try {
            await fetch(`${CONFIG.SERVER_URL}/update_health`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    status: vitality.status,
                    avg_speed: parseFloat(vitality.avgSpeed),
                    score: vitality.score
                })
            });
        } catch (error) {
            console.error("ÂÖÉÊ∞óÂ∫¶ÈÄÅ‰ø°„Ç®„É©„Éº:", error);
        }
    },
    
    reset() {
        this.trackHistory.clear();
        this.speedHistory = [];
        this.lastFrameTime = null;
        console.log("[ÂÖÉÊ∞óÂ∫¶] ËøΩË∑°„Éá„Éº„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü");
    }
};// ÁîªÂÉèÂá¶ÁêÜ„ÉªÈÄÅ‰ø°Ê©üËÉΩ

const imageModule = {
    lastUpdateTime: 0,
    frameCount: 0,
    
    async sendFrame() {
        this.frameCount++;
        
        console.log(`[Frame ${this.frameCount}] ÈñãÂßã`, {
            showingAnalysis: appState.showingAnalysis,
            isSending: appState.isSending,
            modelLoaded: browserDetectionModule.modelLoaded
        });
        
        if (!elements.video.videoWidth || !elements.video.videoHeight) {
            console.log('[Frame] „Çπ„Ç≠„ÉÉ„Éó: „Éì„Éá„Ç™„Çµ„Ç§„Ç∫Êú™Ë®≠ÂÆö');
            return;
        }
        
        if (appState.isSending) {
            console.log('[Frame] „Çπ„Ç≠„ÉÉ„Éó: Âá¶ÁêÜ‰∏≠');
            return;
        }
        
        if (!browserDetectionModule.modelLoaded) {
            console.log('[Frame] „Çπ„Ç≠„ÉÉ„Éó: „É¢„Éá„É´Êú™Ë™≠„ÅøËæº„Åø');
            return;
        }
        
        if (!appState.showingAnalysis) {
            console.log('[Frame] „Ç´„É°„É©„É¢„Éº„Éâ - „Çπ„Ç≠„ÉÉ„Éó');
            return;
        }
        console.log('Ë©≥Á¥∞Á¢∫Ë™ç:', {
    'video.videoWidth': elements.video.videoWidth,
    'video.videoHeight': elements.video.videoHeight,
    'showingAnalysis': appState.showingAnalysis,
    'isSending': appState.isSending,
    'modelLoaded': browserDetectionModule.modelLoaded,
    'videoË¶ÅÁ¥†': elements.video,
    'canvasË¶ÅÁ¥†': elements.displayCanvas
});
        console.log('[Frame] Ëß£ÊûêÁµêÊûú„É¢„Éº„Éâ - Âá¶ÁêÜÈñãÂßã');
        appState.isSending = true;
        
        try {    
            const detections = await browserDetectionModule.detectObjects(elements.video);
            elements.displayCanvas.width = videoWidth;
            elements.displayCanvas.height = videoHeight;
            
            const ctx = elements.displayCanvas.getContext('2d');
            ctx.clearRect(0, 0, videoWidth, videoHeight);
            ctx.drawImage(elements.video, 0, 0);
            
            console.log('[Frame] „Éì„Éá„Ç™ÊèèÁîªÂÆå‰∫Ü');
            
            if (detections.length > 0) {
                browserDetectionModule.drawDetections(elements.displayCanvas, detections);
                console.log('[Frame] „Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„ÇπÊèèÁîªÂÆå‰∫Ü');
                
                const vitality = medakaVitalityModule.update(detections);
                if (vitality.dataPoints >= 30) {
                    medakaVitalityModule.sendVitalityToServer(vitality).catch(() => {});
                }
            }
            
            if (appState.isFullscreen) {
                this.updateFullscreenWithCanvas();
            }
            
            console.log('[Frame] Âá¶ÁêÜÂÆå‰∫Ü');
            
        } catch (error) {
            console.error("‚ùå [Frame] „Ç®„É©„Éº:", error);
        } finally {
            appState.isSending = false;
            console.log('[Frame] „Éï„É©„Ç∞„É™„Çª„ÉÉ„Éà');
        }
    },   
    updateFullscreenWithCanvas() {
        if (!appState.isFullscreen) return;
        
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        elements.fullscreenCanvas.width = screenWidth;
        elements.fullscreenCanvas.height = screenHeight;
        
        const ctx = fullscreenCtx;
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        const canvasAspectRatio = elements.displayCanvas.width / elements.displayCanvas.height;
        const screenAspectRatio = screenWidth / screenHeight;
        
        let drawWidth, drawHeight, drawX, drawY;
        
        if (canvasAspectRatio > screenAspectRatio) {
            drawWidth = screenWidth;
            drawHeight = screenWidth / canvasAspectRatio;
            drawX = 0;
            drawY = (screenHeight - drawHeight) / 2;
        } else {
            drawWidth = screenHeight * canvasAspectRatio;
            drawHeight = screenHeight;
            drawX = (screenWidth - drawWidth) / 2;
            drawY = 0;
        }
        
        ctx.clearRect(0, 0, screenWidth, screenHeight);
        ctx.drawImage(elements.displayCanvas, drawX, drawY, drawWidth, drawHeight);
    }
};

const speechModule = {
    mediaRecorder: null,
    audioChunks: [],
    audioContext: null,
    analyser: null,
    silenceTimeout: null,
    stream: null,
    isListening: false,
    vadPaused: false,  // üÜï VAD‰∏ÄÊôÇÂÅúÊ≠¢„Éï„É©„Ç∞
    
    // VADË®≠ÂÆö
    SILENCE_THRESHOLD: 0.08,      // ÁÑ°Èü≥Âà§ÂÆö„ÅÆÈñæÂÄ§Ôºà0.015 ‚Üí 0.08Ôºâ
    SILENCE_DURATION: 1500,       // ÁÑ°Èü≥„ÅåÁ∂ö„ÅÑ„Åü„ÇâÂÅúÊ≠¢Ôºà„Éü„É™ÁßíÔºâ
    VOICE_THRESHOLD: 0.3,        // Èü≥Â£∞Ê§úÂá∫„ÅÆÈñæÂÄ§Ôºà0.035 ‚Üí 0.10Ôºâ
    MIN_RECORDING_TIME: 500,      // ÊúÄ‰ΩéÈå≤Èü≥ÊôÇÈñìÔºà„Éü„É™ÁßíÔºâ
    recordingStartTime: null,

    init() {
        console.log('[Èü≥Â£∞] Whisper API + VAD „É¢„Éº„Éâ„ÅßÂàùÊúüÂåñ');
    },

    async startListening() {
        if (this.isListening) return;
        
        try {
            const sessionResponse = await fetch(`${CONFIG.SERVER_URL}/check_session_status`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ profile_id: CONFIG.PROFILE_ID })
            });
            
            const sessionData = await sessionResponse.json();
            
            if (sessionData.has_active_session) {
                console.log("[Èü≥Â£∞ÂæÖÊ©ü] 2ÂõûÁõÆ„Éï„É≠„Éº - Èü≥Â£∞Ê§úÂá∫ÂæÖÊ©üÈñãÂßã");
                await this.startVoiceDetection();
            } else if (sessionData.proactive_enabled) {
                console.log("[Èü≥Â£∞ÂæÖÊ©ü] 1ÂõûÁõÆ„Éï„É≠„Éº - „É°„ÉÄ„Ç´„Åã„ÇâË©±„Åó„Åã„Åë");
                await this.startWithMedakaGreeting();
            } else {
                console.log("[Èü≥Â£∞ÂæÖÊ©ü] 1ÂõûÁõÆ„Éï„É≠„Éº - Èü≥Â£∞Ê§úÂá∫ÂæÖÊ©üÈñãÂßã");
                await this.startVoiceDetection();
            }
        } catch (error) {
            console.error("„Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖãÁ¢∫Ë™ç„Ç®„É©„Éº:", error);
            await this.startVoiceDetection();
        }
    },

    async startVoiceDetection() {
        if (this.isListening) return;
        
        try {
            this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048;
            
            const source = this.audioContext.createMediaStreamSource(this.stream);
            source.connect(this.analyser);
            
            this.isListening = true;
            this.vadPaused = false;  // üÜï ÂàùÊúüÂåñ
            elements.statusDiv.textContent = "üé§ Ë©±„Åó„Åã„Åë„Å¶„Åè„Å†„Åï„ÅÑ...";
            elements.statusDiv.classList.remove('recording');
            console.log('[VAD] Èü≥Â£∞Ê§úÂá∫ÈñãÂßã');
            
            this.monitorVoiceLevel();
            
        } catch (error) {
            console.error("Èü≥Â£∞Ê§úÂá∫ÈñãÂßã„Ç®„É©„Éº:", error);
            elements.statusDiv.textContent = "‚ö†Ô∏è „Éû„Ç§„ÇØ„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÅåÊãíÂê¶„Åï„Çå„Åæ„Åó„Åü";
        }
    },

    monitorVoiceLevel() {
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const checkVoice = () => {
            if (!this.isListening) return;
            
            this.analyser.getByteTimeDomainData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                const normalized = (dataArray[i] - 128) / 128;
                sum += normalized * normalized;
            }
            const rms = Math.sqrt(sum / bufferLength);
            
            if (!appState.isRecording && rms > this.VOICE_THRESHOLD) {
                console.log('[VAD] Èü≥Â£∞Ê§úÂá∫! „É¨„Éô„É´:', rms.toFixed(4));
                this.startDirectRecording();
            }
            
            if (appState.isRecording) {
                if (rms < this.SILENCE_THRESHOLD) {
                    if (!this.silenceTimeout) {
                        this.silenceTimeout = setTimeout(() => {
                            const recordingDuration = Date.now() - this.recordingStartTime;
                            if (recordingDuration >= this.MIN_RECORDING_TIME) {
                                console.log('[VAD] ÁÑ°Èü≥Ê§úÂá∫ - Èå≤Èü≥ÂÅúÊ≠¢');
                                this.stopRecording();
                            }
                        }, this.SILENCE_DURATION);
                    }
                } else {
                    if (this.silenceTimeout) {
                        clearTimeout(this.silenceTimeout);
                        this.silenceTimeout = null;
                    }
                }
            }
            
            requestAnimationFrame(checkVoice);
        };
        
        checkVoice();
    },

    async startDirectRecording() {
        if (appState.isRecording) return;
        
        // üîí VAD„Åå‰∏ÄÊôÇÂÅúÊ≠¢‰∏≠„ÅØÈå≤Èü≥ÈñãÂßã„Åó„Å™„ÅÑ
        if (this.vadPaused) {
            console.log('[Èå≤Èü≥] „Çπ„Ç≠„ÉÉ„Éó - VAD‰∏ÄÊôÇÂÅúÊ≠¢‰∏≠');
            return;
        }
        
        try {
            this.recordingStartTime = Date.now();
            
            this.mediaRecorder = new MediaRecorder(this.stream, {
                mimeType: 'audio/webm'
            });
            
            this.audioChunks = [];
            
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.audioChunks.push(event.data);
                }
            };
            
            this.mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                await this.sendAudioToServer(audioBlob);
            };
            
            this.mediaRecorder.start();
            appState.isRecording = true;
            elements.statusDiv.textContent = "üé§ ËÅû„ÅÑ„Å¶„ÅÑ„Åæ„Åô...";
            elements.statusDiv.classList.add('recording');
            
            console.log('[Èå≤Èü≥] ÈñãÂßã');
            
        } catch (error) {
            console.error("Èå≤Èü≥ÈñãÂßã„Ç®„É©„Éº:", error);
            elements.statusDiv.textContent = "‚ö†Ô∏è Èå≤Èü≥ÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü";
        }
    },

    stopRecording() {
        if (this.silenceTimeout) {
            clearTimeout(this.silenceTimeout);
            this.silenceTimeout = null;
        }
         
        if (this.mediaRecorder && appState.isRecording) {
            this.mediaRecorder.stop();
            appState.isRecording = false;
            elements.statusDiv.classList.remove('recording');
            elements.statusDiv.textContent = "üîÑ Âá¶ÁêÜ‰∏≠...";
            
            // üîí Èå≤Èü≥ÂÅúÊ≠¢„Åó„Åü„Çâ‰∏ÄÊôÇÁöÑ„Å´VAD„ÇíÂÅúÊ≠¢
            this.pauseVAD();
            
            console.log('[Èå≤Èü≥] ÂÅúÊ≠¢');
        }
    },

    pauseVAD() {
        // VADÁõ£Ë¶ñ„Çí‰∏ÄÊôÇÂÅúÊ≠¢ÔºàisListening„ÅØtrue„ÅÆ„Åæ„Åæ„ÄÅÈü≥Â£∞Ê§úÂá∫„Å†„ÅëÁÑ°ÂäπÂåñÔºâ
        this.vadPaused = true;
        console.log('[VAD] üîí ‰∏ÄÊôÇÂÅúÊ≠¢ - „É°„ÉÄ„Ç´„ÅÆÂøúÁ≠îÂæÖ„Å°');
    },

    resumeVAD() {
        // VADÁõ£Ë¶ñ„ÇíÂÜçÈñã
        this.vadPaused = false;
        console.log('[VAD] ‚úÖ ÂÜçÈñã - Ê¨°„ÅÆÈü≥Â£∞„ÇíÂæÖÊ©ü');
    },

    stopListening() {
        this.isListening = false;
        this.vadPaused = false;
        
        if (this.silenceTimeout) {
            clearTimeout(this.silenceTimeout);
            this.silenceTimeout = null;
        }
        
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        
        if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
        }
        
        elements.statusDiv.textContent = "‚èπÔ∏è Èü≥Â£∞Ê§úÂá∫ÂÅúÊ≠¢";
        elements.statusDiv.classList.remove('recording');
        console.log('[VAD] Èü≥Â£∞Ê§úÂá∫ÂÅúÊ≠¢');
    },

    async sendAudioToServer(audioBlob) {
        try {
            elements.statusDiv.textContent = "üîÑ Èü≥Â£∞„ÇíË™çË≠ò„Åó„Å¶„ÅÑ„Åæ„Åô...";
            console.log('[„Çµ„Éº„Éê„ÉºÈÄÅ‰ø°] Èü≥Â£∞„Éá„Éº„ÇøÈÄÅ‰ø°‰∏≠...');
            
            const formData = new FormData();
            formData.append('file', audioBlob, 'recording.webm');
            
            const response = await fetch(`${CONFIG.SERVER_URL}/talk_with_fish_audio`, {
                method: "POST",
                body: formData
            });
            
            if (!response.ok) {
                throw new Error('„Çµ„Éº„Éê„Éº„Ç®„É©„Éº');
            }
            
            console.log('[„Çµ„Éº„Éê„ÉºÈÄÅ‰ø°] ÂøúÁ≠îÂèó‰ø°ÂÆå‰∫Ü');
            
            const audioResponseBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioResponseBlob);
            
            // üêü „É°„ÉÄ„Ç´„ÅÆÈü≥Â£∞ÂÜçÁîüÈñãÂßã
            elements.statusDiv.textContent = "üêü „É°„ÉÄ„Ç´„ÅåË©±„Åó„Å¶„ÅÑ„Åæ„Åô...";
            console.log('[„É°„ÉÄ„Ç´ÂøúÁ≠î] Èü≥Â£∞ÂÜçÁîüÈñãÂßã');
            
            elements.replyAudio.src = audioUrl;
            
            // ÂÜçÁîü„ÅåÂßã„Åæ„Å£„Åü„Åì„Å®„ÇíÁ¢∫ÂÆü„Å´Ê§úÁü•
            elements.replyAudio.onloadeddata = () => {
                console.log('[„É°„ÉÄ„Ç´ÂøúÁ≠î] Èü≥Â£∞„Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
            };
            
            await elements.replyAudio.play();
            console.log('[„É°„ÉÄ„Ç´ÂøúÁ≠î] play()ÂÆüË°åÂÆå‰∫Ü');
            
            // üéß „É°„ÉÄ„Ç´„ÅÆÈü≥Â£∞„ÅåÁµÇ„Çè„Å£„Åü„ÇâVAD„ÇíÂÜçÈñã
            elements.replyAudio.onended = () => {
                console.log('[„É°„ÉÄ„Ç´ÂøúÁ≠î] Èü≥Â£∞ÂÜçÁîüÁµÇ‰∫Ü');
                elements.statusDiv.textContent = "üé§ Ë©±„Åó„Åã„Åë„Å¶„Åè„Å†„Åï„ÅÑ...";
                appState.shouldRestart = true;
                
                // ‚úÖ „É°„ÉÄ„Ç´„ÅåË©±„ÅóÁµÇ„Çè„Å£„Åü„ÅÆ„ÅßVAD„ÇíÂÜçÈñã
                if (this.isListening) {
                    this.resumeVAD();
                    console.log('[‰ºöË©±] „É°„ÉÄ„Ç´„ÅÆÂøúÁ≠îÂÆå‰∫Ü - Ê¨°„ÅÆÈü≥Â£∞„ÇíÂæÖÊ©ü');
                }
            };
            
        } catch (error) {
            console.error("Èü≥Â£∞ÈÄÅ‰ø°„Ç®„É©„Éº:", error);
            elements.statusDiv.textContent = '‚ö†Ô∏è Èü≥Â£∞Âá¶ÁêÜ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
            appState.shouldRestart = true;
            
            // „Ç®„É©„ÉºÊôÇ„ÇÇVAD„ÇíÂÜçÈñã
            setTimeout(() => {
                if (appState.shouldRestart && this.isListening) {
                    this.resumeVAD();
                    elements.statusDiv.textContent = "üé§ Ë©±„Åó„Åã„Åë„Å¶„Åè„Å†„Åï„ÅÑ...";
                    console.log('[„Ç®„É©„ÉºÂæ©Â∏∞] VADÂÜçÈñã');
                }
            }, 2000);
        }
    },

    async startWithMedakaGreeting() {
        try {
            elements.statusDiv.textContent = "üêü „É°„ÉÄ„Ç´„ÅåË©±„Åó„Åã„Åë„Å¶„ÅÑ„Åæ„Åô...";
            
            const greetingResponse = await fetch(`${CONFIG.SERVER_URL}/get_proactive_message`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ profile_id: CONFIG.PROFILE_ID })
            });
            
            const greetingBlob = await greetingResponse.blob();
            const greetingUrl = URL.createObjectURL(greetingBlob);
            elements.replyAudio.src = greetingUrl;
            
            await elements.replyAudio.play();
            
            elements.replyAudio.onended = () => {
                elements.statusDiv.textContent = "üé§ „É°„ÉÄ„Ç´„ÅåË©±„Åó„Åã„Åë„Åü„Çà„ÄÇ„ÅäËøî‰∫ã„Åó„Å¶„Å≠ÔºÅ";
                setTimeout(() => {
                    this.startVoiceDetection();
                }, 1000);
            };
            
        } catch (error) {
            console.error("„É°„ÉÄ„Ç´Êå®Êã∂„Ç®„É©„Éº:", error);
            this.startVoiceDetection();
        }
    }
};

// „Éï„É´„Çπ„ÇØ„É™„Éº„É≥Ê©üËÉΩ
const fullscreenModule = {
    enterFullscreen() {
        appState.isFullscreen = true;
        elements.fullscreenContainer.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        elements.canvasFullscreenBtn.textContent = 'üì± Êàª„Çã';
        
        if (appState.showingAnalysis && appState.currentImageData) {
            this.updateFullscreenCanvas(appState.currentImageData);
        } else {
            this.displayVideoInFullscreen();
        }
    },

    exitFullscreen() {
        appState.isFullscreen = false;
        elements.fullscreenContainer.classList.add('hidden');
        document.body.style.overflow = 'auto';
        elements.canvasFullscreenBtn.textContent = 'üîç Êã°Â§ß';
        
        if (this.videoRenderInterval) {
            clearInterval(this.videoRenderInterval);
            this.videoRenderInterval = null;
        }
    },

    displayVideoInFullscreen() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        elements.fullscreenCanvas.width = screenWidth;
        elements.fullscreenCanvas.height = screenHeight;
        elements.fullscreenCanvas.style.width = `${screenWidth}px`;
        elements.fullscreenCanvas.style.height = `${screenHeight}px`;
        
        fullscreenCtx.imageSmoothingEnabled = true;
        fullscreenCtx.imageSmoothingQuality = 'high';
        
        const renderVideo = () => {
            if (!appState.isFullscreen) return;
            
            const videoWidth = elements.video.videoWidth;
            const videoHeight = elements.video.videoHeight;
            
            if (videoWidth && videoHeight) {
                const imageAspectRatio = videoWidth / videoHeight;
                const screenAspectRatio = screenWidth / screenHeight;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageAspectRatio > screenAspectRatio) {
                    drawWidth = screenWidth;
                    drawHeight = screenWidth / imageAspectRatio;
                    drawX = 0;
                    drawY = (screenHeight - drawHeight) / 2;
                } else {
                    drawWidth = screenHeight * imageAspectRatio;
                    drawHeight = screenHeight;
                    drawX = (screenWidth - drawWidth) / 2;
                    drawY = 0;
                }
                
                fullscreenCtx.clearRect(0, 0, screenWidth, screenHeight);
                fullscreenCtx.drawImage(elements.video, drawX, drawY, drawWidth, drawHeight);
            }
        };
        
        if (this.videoRenderInterval) {
            clearInterval(this.videoRenderInterval);
        }
        this.videoRenderInterval = setInterval(renderVideo, 33);
        renderVideo();
    },

    updateFullscreenCanvas(resultImg) {
        if (!appState.isFullscreen) return;
        
        if (this.videoRenderInterval) {
            clearInterval(this.videoRenderInterval);
            this.videoRenderInterval = null;
        }
        
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        elements.fullscreenCanvas.width = screenWidth;
        elements.fullscreenCanvas.height = screenHeight;
        elements.fullscreenCanvas.style.width = `${screenWidth}px`;
        elements.fullscreenCanvas.style.height = `${screenHeight}px`;
        
        fullscreenCtx.imageSmoothingEnabled = true;
        fullscreenCtx.imageSmoothingQuality = 'high';
        
        const imageAspectRatio = resultImg.naturalWidth / resultImg.naturalHeight;
        const screenAspectRatio = screenWidth / screenHeight;
        
        let drawWidth, drawHeight, drawX, drawY;
        
        if (imageAspectRatio > screenAspectRatio) {
            drawWidth = screenWidth;
            drawHeight = screenWidth / imageAspectRatio;
            drawX = 0;
            drawY = (screenHeight - drawHeight) / 2;
        } else {
            drawWidth = screenHeight * imageAspectRatio;
            drawHeight = screenHeight;
            drawX = (screenWidth - drawWidth) / 2;
            drawY = 0;
        }
        
        fullscreenCtx.clearRect(0, 0, screenWidth, screenHeight);
        fullscreenCtx.drawImage(resultImg, drawX, drawY, drawWidth, drawHeight);
    },

    setupEventListeners() {
        elements.canvasFullscreenBtn.addEventListener('click', () => {
            if (appState.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        });

        elements.displayCanvas.addEventListener('click', () => {
            if (!appState.isFullscreen) {
                if (appState.showingAnalysis) {
                    this.enterFullscreen();
                }
            }
        });

        elements.exitBtn.addEventListener('click', () => this.exitFullscreen());
    }
};

// UIÂà∂Âæ°Ê©üËÉΩ
const uiModule = {
    setupVADButtons() {
        elements.vadStartBtn.addEventListener('click', () => {
            speechModule.startListening();
            elements.vadStartBtn.disabled = true;
            elements.vadStopBtn.disabled = false;
        });
        
        elements.vadStopBtn.addEventListener('click', () => {
            speechModule.stopListening();
            elements.vadStartBtn.disabled = false;
            elements.vadStopBtn.disabled = true;
        });
    },
    
    setupStartButton() {
        elements.startButton.addEventListener("click", () => {
            elements.replyAudio.src = "";
            elements.replyAudio.load();
            setTimeout(() => {
                appState.shouldRestart = true;
                elements.startButton.classList.add('hidden');
                elements.vadControls.classList.remove('hidden');
                elements.statusDiv.textContent = "üé§ „ÄåÈü≥Â£∞Ê§úÂá∫ÈñãÂßã„Äç„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
                
                elements.vadStartBtn.disabled = false;
                elements.vadStopBtn.disabled = true;
            }, 500);
        });
    },
    
setupSwitchButton() {
    console.log('[ÂàùÊúüÂåñ] Âàá„ÇäÊõø„Åà„Éú„Çø„É≥Ë®≠ÂÆöÈñãÂßã');
    
    elements.switchViewBtn.addEventListener('click', () => {
        console.log('[„Éú„Çø„É≥] „ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„Åæ„Åó„Åü');
        
        appState.showingAnalysis = !appState.showingAnalysis;
        
        console.log('[„Éú„Çø„É≥] showingAnalysis =', appState.showingAnalysis);
        
        if (appState.showingAnalysis) {
            // Ëß£ÊûêÁµêÊûú„É¢„Éº„Éâ
            elements.video.classList.add('hidden');
            elements.displayCanvas.classList.remove('hidden');
            elements.switchViewBtn.textContent = 'üìπ „Ç´„É°„É©';
            
            console.log('[„Éú„Çø„É≥] Ëß£ÊûêÁµêÊûú„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„ÅàÂÆå‰∫Ü');
            console.log('[„Éú„Çø„É≥] video hidden:', elements.video.classList.contains('hidden'));
            console.log('[„Éú„Çø„É≥] canvas hidden:', elements.displayCanvas.classList.contains('hidden'));
            
        } else {
            // „Ç´„É°„É©„É¢„Éº„Éâ
            elements.video.classList.remove('hidden');
            elements.displayCanvas.classList.add('hidden');
            elements.switchViewBtn.textContent = 'üìä Ëß£ÊûêÁµêÊûú';
            
            console.log('[„Éú„Çø„É≥] „Ç´„É°„É©„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„ÅàÂÆå‰∫Ü');
        }
    });
    
    console.log('[ÂàùÊúüÂåñ] Âàá„ÇäÊõø„Åà„Éú„Çø„É≥Ë®≠ÂÆöÂÆå‰∫Ü');
}
};

// „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÂàùÊúüÂåñ„Éª„É°„Ç§„É≥Âá¶ÁêÜ
const app = {
    async init() {
        elements.vadControls.classList.add('hidden');
        
        // ‚úÖ „Éñ„É©„Ç¶„Ç∂Ê§úÂá∫„É¢„Éá„É´„ÇíË™≠„ÅøËæº„Åø
        await browserDetectionModule.loadModel();
        
        await cameraModule.startCamera();
        speechModule.init();
        fullscreenModule.setupEventListeners();
        uiModule.setupVADButtons();
        uiModule.setupStartButton();
        uiModule.setupSwitchButton();
        
        setInterval(() => imageModule.sendFrame(), CONFIG.FRAME_RATE);
        
        this.optimizeTouchEvents();
        
        console.log('üê† È≠öË™çË≠ò„Ç¢„Éó„É™„ÅåÂàùÊúüÂåñ„Åï„Çå„Åæ„Åó„Åü („Éñ„É©„Ç¶„Ç∂Ê§úÂá∫)');
    },

    optimizeTouchEvents() {
        document.addEventListener('touchstart', function(){}, {passive: true});
        document.addEventListener('touchmove', function(){}, {passive: true});
    }
};

app.init();
  </script>
</body>
</html>