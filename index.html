<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ãƒ¡ãƒ€ã‚«ã®è¦³å¯Ÿã¨ä¼šè©±</title>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      overflow-x: hidden;
    }
    
    .container {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    
    h1 {
      font-size: 1.5rem;
      margin: 10px 0;
      text-align: center;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .display-section {
      width: 100%;
      max-width: 400px;
      margin-bottom: 10px;
    }
    
    .view-container {
      position: relative;
      width: 100%;
    }
    
    #video, #displayCanvas {
      width: 100%;
      height: auto;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      background: rgba(0,0,0,0.5);
    }
    
    #displayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    
    #displayCanvas:active {
      transform: scale(0.98);
    }
    
    .fullscreen-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      border-radius: 20px;
      padding: 8px 12px;
      font-size: 12px;
      cursor: pointer;
      z-index: 10;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
    }
    
    .fullscreen-button:hover {
      background: rgba(0,0,0,0.9);
      transform: scale(1.05);
    }
    
    .switch-button {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      border-radius: 20px;
      padding: 8px 12px;
      font-size: 12px;
      cursor: pointer;
      z-index: 10;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
    }
    
    .switch-button:hover {
      background: rgba(0,0,0,0.9);
      transform: scale(1.05);
    }
    
    .switch-button:active {
      transform: scale(0.95);
    }
    
    .fullscreen-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    
    .fullscreen-canvas {
      max-width: 100vw;
      max-height: 80vh;
      object-fit: contain;
    }
    
    .fullscreen-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 1001;
    }
    
    .control-button {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: none;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      backdrop-filter: blur(10px);
    }
    
    .exit-button {
      background: linear-gradient(135deg, #2c2c54, #40407a);
      color: white;
      font-size: 18px;
    }
    
    .control-button:active {
      transform: scale(0.9);
    }
    
    @keyframes pulse {
      0% { 
        transform: scale(1); 
        box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.7);
      }
      50% { 
        transform: scale(1.05); 
        box-shadow: 0 0 20px 10px rgba(255, 107, 107, 0);
      }
      100% { 
        transform: scale(1); 
        box-shadow: 0 0 0 0 rgba(255, 107, 107, 0);
      }
    }
    
    .status-section {
      width: 100%;
      max-width: 400px;
      text-align: center;
      margin: 15px 0;
    }
    
    #status {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      border: 1px solid rgba(255,255,255,0.2);
      transition: all 0.3s ease;
    }
    
    #status.recording {
      background: linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(238, 90, 36, 0.3));
      animation: pulse 1.5s infinite;
    }
    
    #startButton {
      background: linear-gradient(135deg, #4facfe, #00f2fe);
      color: white;
      border: none;
      border-radius: 25px;
      padding: 15px 30px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(79, 172, 254, 0.4);
      transition: all 0.3s ease;
      margin-top: 20px;
    }
    
    #startButton:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(79, 172, 254, 0.6);
    }
    
    #startButton:active {
      transform: translateY(0);
    }
    
    .vad-controls {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      justify-content: center;
    }
    
    .vad-button {
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
    }
    
    .vad-start-button {
      background: linear-gradient(135deg, #11998e, #38ef7d);
      color: white;
    }
    
    .vad-start-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(17, 153, 142, 0.4);
    }
    
    .vad-stop-button {
      background: linear-gradient(135deg, #ff6b6b, #ee5a24);
      color: white;
    }
    
    .vad-stop-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }
    
    .hidden {
      display: none !important;
    }
    .account-section {
        display: flex;
        gap: 10px;
        margin: 10px 0;
        justify-content: center;
    }
    .profile-selector {
        padding: 10px 15px;
        border-radius: 20px;
        border: 2px solid rgba(255,255,255,0.3);
        background: rgba(255,255,255,0.1);
        color: white;
        font-size: 14px;
    }
    .account-btn {
        padding: 10px 20px;
        border-radius: 20px;
        border: none;
        background: linear-gradient(135deg, #f093fb, #f5576c);
        color: white;
        cursor: pointer;
    }
    @media (max-width: 768px) {
      .container {
        padding: 5px;
      }
      
      h1 {
        font-size: 1.3rem;
        margin: 5px 0;
      }
      
      .display-section,
      .status-section {
        max-width: 95vw;
      }
      
      .fullscreen-controls {
        bottom: 30px;
      }
      
      .control-button {
        width: 60px;
        height: 60px;
        font-size: 20px;
      }
    }
  </style>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>ãƒ¡ãƒ€ã‚«ã«ãŠè©±ã—ã—ã¦ã­ï¼</h1>
    <div class="account-section">
  <select id="profileSelect" class="profile-selector">
    <option value="">ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠ...</option>
  </select>
  <button id="addAccountBtn" class="account-btn">â• æ–°è¦ä½œæˆ</button>
</div>
    <div class="display-section">
      <div class="view-container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="displayCanvas" class="hidden"></canvas>
        <button class="fullscreen-button" id="canvasFullscreenBtn">ğŸ” æ‹¡å¤§</button>
        <button class="switch-button" id="switchViewBtn">ğŸ“Š è§£æçµæœ</button>
      </div>
    </div>
    
    <div class="status-section">
      <div id="status">ğŸ¤ éŸ³å£°å…¥åŠ› å¾…æ©Ÿä¸­...</div>

      <form id="text-form" style="margin: 15px 0;">
          <input type="text" id="text-input" placeholder="ã¾ãŸã¯ã€ãƒ†ã‚­ã‚¹ãƒˆã§è©±ã—ã‹ã‘ã‚‹" style="width: 70%; padding: 10px; border-radius: 20px; border: 1px solid #ccc;">
          <button type="submit" style="padding: 10px 15px; border-radius: 20px; border: none; background: #4facfe; color: white; cursor: pointer;">é€ä¿¡</button>
      </form>
      
      <div class="vad-controls hidden" id="vadControls">
        <button class="vad-button vad-start-button" id="vadStartBtn">ğŸ¤ éŸ³å£°æ¤œå‡ºé–‹å§‹</button>
        <button class="vad-button vad-stop-button" id="vadStopBtn">â¹ï¸ éŸ³å£°æ¤œå‡ºåœæ­¢</button>
      </div>
      
      <button id="startButton">ğŸš€ ä¼šè©±ã‚’å§‹ã‚ã‚‹</button>
    </div>
  </div>
  
  <div class="fullscreen-container hidden" id="fullscreenContainer">
    <canvas id="fullscreenCanvas"></canvas>
    <div class="fullscreen-controls">
      <button class="control-button exit-button" id="exitBtn">âœ•</button>
    </div>
  </div>
  
  <audio id="replyAudio" preload="auto" ></audio>
  
  <script>
document.getElementById('text-form').addEventListener('submit', async function(event) {
    event.preventDefault();
    const textInput = document.getElementById('text-input').value;
    const statusDiv = document.getElementById('status');

    if (!textInput) {
        statusDiv.textContent = 'ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
        return;
    }

    statusDiv.textContent = 'ğŸ”„ ãƒ†ã‚­ã‚¹ãƒˆã‚’å‡¦ç†ä¸­...';

    try {
        const response = await fetch('/talk_with_fish_text', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ text: textInput })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const audioResponseBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioResponseBlob);
        
        statusDiv.textContent = "ğŸŸ ãƒ¡ãƒ€ã‚«ãŒè©±ã—ã¦ã„ã¾ã™...";
        
        const replyAudio = document.getElementById('replyAudio');
        replyAudio.src = audioUrl;
        await replyAudio.play();

        replyAudio.onended = () => {
            statusDiv.textContent = "ğŸ¤ è©±ã—ã‹ã‘ã¦ãã ã•ã„...";
        };

    } catch (error) {
        console.error('Error:', error);
        statusDiv.textContent = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
    }
});
    //ã“ã‚ŒãŒæ¶ˆãˆãŸã‚‰OK

// è¨­å®šãƒ»å®šæ•°
const CONFIG = {
    SERVER_URL: window.location.origin,
    FRAME_RATE: 34  ,
    PROFILE_ID: 1
};
// DOMè¦ç´ ã®å–å¾—
const elements = {
    video: document.getElementById('video'),
    displayCanvas: document.getElementById('displayCanvas'),
    fullscreenCanvas: document.getElementById('fullscreenCanvas'),
    replyAudio: document.getElementById("replyAudio"),
    statusDiv: document.getElementById("status"),
    canvasFullscreenBtn: document.getElementById("canvasFullscreenBtn"),
    fullscreenContainer: document.getElementById("fullscreenContainer"),
    startButton: document.getElementById("startButton"),
    vadControls: document.getElementById("vadControls"),
    vadStartBtn: document.getElementById("vadStartBtn"),
    vadStopBtn: document.getElementById("vadStopBtn"),
    exitBtn: document.getElementById("exitBtn"),
    switchViewBtn: document.getElementById("switchViewBtn")
};
const displayCtx = elements.displayCanvas.getContext('2d');
const fullscreenCtx = elements.fullscreenCanvas.getContext('2d');
// ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ç®¡ç†
const appState = {
    isFullscreen: false,
    currentProfileId: null ,
    currentImageData: null,
    isRecording: false,
    shouldRestart: true,
    isSending: false,
    ws: null,
    wsConnected: false,
    showingAnalysis: false
};
// ãƒ–ãƒ©ã‚¦ã‚¶ç‰©ä½“æ¤œå‡ºãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
const browserDetectionModule = {
    session: null,
    modelLoaded: false,
    inputSize: 640,

    async loadModel() {
        try {
            const modelUrl = `${window.location.origin}/best.onnx`;
            const sessionOptions = {
                executionProviders: ['wasm'],  //iPhoneã§ã¯webglãŒåŠ¹æœçš„ã€Androidã§ã¯wasmãŒå®‰å®š
                graphOptimizationLevel: 'all',
                enableCpuMemArena: false,
                enableMemPattern: false,
                logSeverityLevel: 3
            };
            // âœ… ã¾ãšfetchã§ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const response = await fetch(modelUrl, {
                method: 'GET',
                mode: 'cors',
                cache: 'default',
                credentials: 'omit'
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();        
            // âœ… ArrayBufferã‹ã‚‰ç›´æ¥ãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆ
            this.session = await ort.InferenceSession.create(arrayBuffer, sessionOptions);
            
            this.modelLoaded = true;
            elements.statusDiv.textContent = "âœ… æ¤œå‡ºãƒ¢ãƒ‡ãƒ«æº–å‚™å®Œäº†";
        } catch (error) {
            elements.statusDiv.textContent = "âš ï¸ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—";
        }
    },

    async detectObjects(videoElement) {
        if (!this.modelLoaded) {
            console.warn('[ãƒ–ãƒ©ã‚¦ã‚¶æ¤œå‡º] ãƒ¢ãƒ‡ãƒ«ãŒæœªèª­ã¿è¾¼ã¿');
            return [];
        }

        try {
            // ç”»åƒã‚’å‰å‡¦ç†
            const inputTensor = await this.preprocessImage(videoElement);
            
            // æ¨è«–å®Ÿè¡Œ
            const startTime = performance.now();
            const results = await this.session.run({ images: inputTensor });
            const inferenceTime = performance.now() - startTime;
            // çµæœã‚’å¾Œå‡¦ç†
            const detections = this.postprocess(results);
            
            return detections;
            
        } catch (error) {
            console.error('[ãƒ–ãƒ©ã‚¦ã‚¶æ¤œå‡º] æ¤œå‡ºã‚¨ãƒ©ãƒ¼:', error);
            return [];
        }
    },

    async preprocessImage(videoElement) {
        // Canvasã§ç”»åƒã‚’å–å¾—
        const canvas = document.createElement('canvas');
        canvas.width = this.inputSize;
        canvas.height = this.inputSize;
        const ctx = canvas.getContext('2d');
        // ãƒªã‚µã‚¤ã‚ºã—ã¦æç”»
        ctx.drawImage(videoElement, 0, 0, this.inputSize, this.inputSize);
        // ImageDataã‚’å–å¾—
        const imageData = ctx.getImageData(0, 0, this.inputSize, this.inputSize);
        const pixels = imageData.data;
        const red = new Float32Array(this.inputSize * this.inputSize);
        const green = new Float32Array(this.inputSize * this.inputSize);
        const blue = new Float32Array(this.inputSize * this.inputSize);
        for (let i = 0; i < pixels.length; i += 4) {
            const idx = i / 4;
            red[idx] = pixels[i] / 255.0;     // R
            green[idx] = pixels[i + 1] / 255.0; // G
            blue[idx] = pixels[i + 2] / 255.0;  // B
        }
        // ãƒãƒ£ãƒãƒ«ã‚’çµåˆ
        const input = new Float32Array(3 * this.inputSize * this.inputSize);
        input.set(red, 0);
        input.set(green, this.inputSize * this.inputSize);
        input.set(blue, 2 * this.inputSize * this.inputSize);
        // Tensorã«å¤‰æ›
        return new ort.Tensor('float32', input, [1, 3, this.inputSize, this.inputSize]);
    },

    postprocess(results) {
    const output = results.output0;
    const outputData = output.data;
    const [batchSize, numAttributes, numBoxes] = output.dims;
    const detections = [];
    const confThreshold = 0.6;
    const iouThreshold = 0.45;
    
    // 8400å€‹ã®ãƒœãƒƒã‚¯ã‚¹ã‚’ãƒ«ãƒ¼ãƒ—
    for (let i = 0; i < numBoxes; i++) {
        // YOLOv8å½¢å¼: [cx, cy, w, h, class_scores...]
        const cx = outputData[i];  // ä¸­å¿ƒX
        const cy = outputData[numBoxes + i];  // ä¸­å¿ƒY
        const w = outputData[2 * numBoxes + i];  // å¹…
        const h = outputData[3 * numBoxes + i];  // é«˜ã•
        
        // ã‚¯ãƒ©ã‚¹ã‚¹ã‚³ã‚¢ï¼ˆãƒ¡ãƒ€ã‚«ã¯1ã‚¯ãƒ©ã‚¹ãªã®ã§4ç•ªç›®ã®è¦ç´ ï¼‰
        const classScore = outputData[4 * numBoxes + i];
        
        if (classScore > confThreshold) {
            // ä¸­å¿ƒåº§æ¨™ã‚’å·¦ä¸Šåº§æ¨™ã«å¤‰æ›
            const x = (cx - w / 2) * elements.video.videoWidth / this.inputSize;
            const y = (cy - h / 2) * elements.video.videoHeight / this.inputSize;
            const width = w * elements.video.videoWidth / this.inputSize;
            const height = h * elements.video.videoHeight / this.inputSize;
            
            detections.push({
                x: x,
                y: y,
                width: width,
                height: height,
                confidence: classScore,
                class: 0
            });
        }
    }
    
    // NMSï¼ˆNon-Maximum Suppressionï¼‰ã‚’é©ç”¨
    const filteredDetections = this.applyNMS(detections, iouThreshold);
    return filteredDetections;
},applyNMS(boxes, iouThreshold) {
    // ä¿¡é ¼åº¦ã§ã‚½ãƒ¼ãƒˆ
    boxes.sort((a, b) => b.confidence - a.confidence);
    
    const selected = [];
    const suppressed = new Set();
    
    for (let i = 0; i < boxes.length; i++) {
        if (suppressed.has(i)) continue;
        
        selected.push(boxes[i]);
        
        for (let j = i + 1; j < boxes.length; j++) {
            if (suppressed.has(j)) continue;
            
            const iou = this.calculateIoU(boxes[i], boxes[j]);
            if (iou > iouThreshold) {
                suppressed.add(j);
            }
        }
    }
    
    return selected;
},// IoUï¼ˆIntersection over Unionï¼‰è¨ˆç®—
calculateIoU(box1, box2) {
    const x1 = Math.max(box1.x, box2.x);
    const y1 = Math.max(box1.y, box2.y);
    const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
    const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
    
    const intersectionArea = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
    const box1Area = box1.width * box1.height;
    const box2Area = box2.width * box2.height;
    const unionArea = box1Area + box2Area - intersectionArea;
    
    return intersectionArea / unionArea;
},

    drawDetections(canvas, detections) {
        const ctx = canvas.getContext('2d');
        
        detections.forEach(det => {
            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æç”»
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(det.x, det.y, det.width, det.height);
            
            // ãƒ©ãƒ™ãƒ«æç”»
            ctx.fillStyle = '#00ff00';
            ctx.font = '16px Arial';
            ctx.fillText(`ãƒ¡ãƒ€ã‚« ${(det.confidence * 100).toFixed(0)}%`, 
                        det.x, det.y - 5);
        });
    }
};

// ã‚«ãƒ¡ãƒ©æ©Ÿèƒ½
const cameraModule = {
    async startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    facingMode: "environment",
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            });
            elements.video.srcObject = stream;
        } catch (err) {
            elements.statusDiv.textContent = 'âš ï¸ ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ';
            console.error('Camera error:', err);
        }
    }
};

const medakaVitalityModule = {
    // è¿½è·¡ãƒ‡ãƒ¼ã‚¿
    trackHistory: new Map(),      // ID â†’ [{pos, time}, ...]
    speedHistory: new Map(),      // ID â†’ [speed1, speed2, ...]
    maxHistoryLength: 30,         // 2ç§’åˆ†ã®å±¥æ­´
    fps: 15,
    nextId: 0,
    
    // å…ƒæ°—åº¦åˆ¤å®šã®é–¾å€¤ï¼ˆãƒ”ã‚¯ã‚»ãƒ«/ç§’ï¼‰
    thresholds: {
        active: 40,   // 40px/ç§’ä»¥ä¸Š â†’ å…ƒæ°—
        normal: 10,   // 15-40px/ç§’ â†’ æ™®é€š
    },
    
    lastFrameTime: null,
    
    /**
     * ç‰©ä½“è¿½è·¡ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆæœ€è¿‘å‚æ³•ï¼‰
     */
    trackObjects(detections) {
        const assignedIds = new Map();
        const usedIds = new Set();
        const MAX_DISTANCE = 100;
        
        detections.forEach(det => {
            const currentCenter = {
                x: det.x + det.width / 2,
                y: det.y + det.height / 2
            };
            
            let bestId = null;
            let minDistance = Infinity;
            
            // æ—¢å­˜ã®å…¨ãƒ¡ãƒ€ã‚«ã¨è·é›¢ã‚’æ¯”è¼ƒ
            for (let [id, history] of this.trackHistory.entries()) {
                if (usedIds.has(id)) continue;
                if (history.length === 0) continue;
                
                const lastPos = history[history.length - 1].pos;
                const distance = Math.sqrt(
                    Math.pow(currentCenter.x - lastPos.x, 2) +
                    Math.pow(currentCenter.y - lastPos.y, 2)
                );
                
                if (distance < minDistance && distance < MAX_DISTANCE) {
                    minDistance = distance;
                    bestId = id;
                }
            }
            
            if (bestId !== null) {
                assignedIds.set(det, bestId);
                usedIds.add(bestId);
                console.log(`[è¿½è·¡] ID ${bestId} ç¶™ç¶š (è·é›¢: ${minDistance.toFixed(1)}px)`);
            } else {
                const newId = this.nextId++;
                assignedIds.set(det, newId);
                this.trackHistory.set(newId, []);
                console.log(`[è¿½è·¡] æ–°ãƒ¡ãƒ€ã‚«æ¤œå‡º ID ${newId}`);
            }
        });
        
        return assignedIds;
    },
    
    /**
     * æ¤œå‡ºçµæœã‹ã‚‰é€Ÿåº¦ã‚’è¨ˆç®—ã—ã¦å…ƒæ°—åº¦ã‚’æ›´æ–°
     */
    update(detections) {
        const currentTime = performance.now();
        
        // FPSè¨ˆç®—
        if (this.lastFrameTime) {
            const deltaTime = (currentTime - this.lastFrameTime) / 1000;
            this.fps = 1 / deltaTime;
        }
        this.lastFrameTime = currentTime;
        
        // è¿½è·¡ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§IDã‚’å‰²ã‚Šå½“ã¦
        const assignedIds = this.trackObjects(detections);
        
        // å„ãƒ¡ãƒ€ã‚«ã®é€Ÿåº¦ã‚’å€‹åˆ¥ã«è¨ˆç®—
        detections.forEach(det => {
            const medakaId = assignedIds.get(det);
            const currentPos = {
                x: det.x + det.width / 2,
                y: det.y + det.height / 2
            };
            
            // é€Ÿåº¦è¨ˆç®—
            const speed = this.calculateSpeed(medakaId, currentPos);
            
            if (speed !== null) {
                // ãƒ¡ãƒ€ã‚«ã”ã¨ã«é€Ÿåº¦ã‚’ä¿å­˜
                if (!this.speedHistory.has(medakaId)) {
                    this.speedHistory.set(medakaId, []);
                }
                const speeds = this.speedHistory.get(medakaId);
                speeds.push(speed);
                
                if (speeds.length > this.maxHistoryLength) {
                    speeds.shift();
                }
            }
            
            // ä½ç½®ã‚’å±¥æ­´ã«è¿½åŠ 
            const history = this.trackHistory.get(medakaId);
            history.push({ pos: currentPos, time: currentTime });
            
            if (history.length > 10) {
                history.shift();
            }
        });
        
        // å¤ã„è¿½è·¡ã‚’å‰Šé™¤ï¼ˆ5ç§’é–“æ¤œå‡ºã•ã‚Œãªã‹ã£ãŸãƒ¡ãƒ€ã‚«ï¼‰
        const tracksToDelete = [];
        for (let [id, history] of this.trackHistory.entries()) {
            if (history.length === 0) continue;
            const lastTime = history[history.length - 1].time;
            if (currentTime - lastTime > 5000) {
                tracksToDelete.push(id);
            }
        }
        tracksToDelete.forEach(id => {
            console.log(`[è¿½è·¡] ID ${id} ã‚’å‰Šé™¤ï¼ˆ5ç§’é–“æœªæ¤œå‡ºï¼‰`);
            this.trackHistory.delete(id);
            this.speedHistory.delete(id);
        });
        
        // ğŸ”¥ æœ€ã‚‚å…ƒæ°—ãªãƒ¡ãƒ€ã‚«ã®çŠ¶æ…‹ã‚’æ¡ç”¨
        const vitality = this.getBestVitality();
        
        return vitality;
    },
    
    /**
     * ãƒ¡ãƒ€ã‚«ã®é€Ÿåº¦ã‚’è¨ˆç®—ï¼ˆãƒ”ã‚¯ã‚»ãƒ«/ç§’ï¼‰
     */
    calculateSpeed(medakaId, currentPos) {
        const history = this.trackHistory.get(medakaId);
        
        if (!history || history.length < 2) {
            return null;
        }
        
        const prevData = history[history.length - 1];
        const prevPos = prevData.pos;
        const prevTime = prevData.time;
        
        // è·é›¢ã‚’è¨ˆç®—ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
        const distance = Math.sqrt(
            Math.pow(currentPos.x - prevPos.x, 2) + 
            Math.pow(currentPos.y - prevPos.y, 2)
        );
        
        // æ™‚é–“å·®ï¼ˆç§’ï¼‰
        const deltaTime = (performance.now() - prevTime) / 1000;
        
        if (deltaTime === 0) return null;
        
        // é€Ÿåº¦ï¼ˆãƒ”ã‚¯ã‚»ãƒ«/ç§’ï¼‰
        const speed = distance / deltaTime;
        
        return speed;
    },
    
    /**
     * ğŸ”¥ æœ€ã‚‚å…ƒæ°—ãªãƒ¡ãƒ€ã‚«ã®å…ƒæ°—åº¦ã‚’è¿”ã™
     */
    getBestVitality() {
        if (this.speedHistory.size === 0) {
            return {
                status: "Unknown",
                statusJa: "ä¸æ˜",
                avgSpeed: 0,
                score: 0,
                color: "#999999",
                medakaId: null,
                trackedCount: 0
            };
        }
        
        let bestVitality = null;
        let maxScore = -1;
        
        // å„ãƒ¡ãƒ€ã‚«ã®å…ƒæ°—åº¦ã‚’è¨ˆç®—ã—ã€æœ€é«˜ã‚¹ã‚³ã‚¢ã‚’é¸æŠ
        for (let [id, speeds] of this.speedHistory.entries()) {
            if (speeds.length < 10) continue;  // æœ€ä½10ãƒ•ãƒ¬ãƒ¼ãƒ å¿…è¦
            
            const vitality = this.calculateVitalityForMedaka(id, speeds);
            
            if (vitality.score > maxScore) {
                maxScore = vitality.score;
                bestVitality = vitality;
            }
        }
        
        // ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã®å ´åˆ
        if (bestVitality === null) {
            return {
                status: "Unknown",
                statusJa: "ä¸æ˜",
                avgSpeed: 0,
                score: 0,
                color: "#999999",
                medakaId: null,
                trackedCount: this.speedHistory.size
            };
        }
        
        // è¿½è·¡ä¸­ã®ãƒ¡ãƒ€ã‚«æ•°ã‚’è¿½åŠ 
        bestVitality.trackedCount = this.speedHistory.size;
        
        console.log(`[å…ƒæ°—åº¦] æœ€ã‚‚å…ƒæ°—: ID ${bestVitality.medakaId} (ã‚¹ã‚³ã‚¢: ${bestVitality.score})`);
        
        return bestVitality;
    },
    
    /**
     * ğŸ”¥ å€‹åˆ¥ãƒ¡ãƒ€ã‚«ã®å…ƒæ°—åº¦ã‚’è¨ˆç®—
     */
    calculateVitalityForMedaka(medakaId, speeds) {
        const avgSpeed = speeds.reduce((sum, s) => sum + s, 0) / speeds.length;
        
        let status, statusJa, score, color;
        
        if (avgSpeed >= this.thresholds.active) {
            status = "Active";
            statusJa = "å…ƒæ°—";
            score = 100;
            color = "#00ff00";
        } else if (avgSpeed >= this.thresholds.normal) {
            status = "Normal";
            statusJa = "æ™®é€š";
            score = 70;
            color = "#ffff00";
        } else {
            status = "Lethargic";
            statusJa = "å…ƒæ°—ãªã„";
            score = 30;
            color = "#ff0000";
        }
        
        return {
            medakaId,
            status,
            statusJa,
            avgSpeed: avgSpeed.toFixed(2),
            score,
            color,
            dataPoints: speeds.length
        };
    },
    
    /**
     * å…ƒæ°—åº¦ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
     */
    async sendVitalityToServer(vitality) {
        try {
            await fetch(`${CONFIG.SERVER_URL}/update_health`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    status: vitality.status,
                    avg_speed: parseFloat(vitality.avgSpeed),
                    score: vitality.score
                })
            });
        } catch (error) {
            console.error("å…ƒæ°—åº¦é€ä¿¡ã‚¨ãƒ©ãƒ¼:", error);
        }
    },
    
    /**
     * ãƒªã‚»ãƒƒãƒˆ
     */
    reset() {
        this.trackHistory.clear();
        this.speedHistory.clear();
        this.lastFrameTime = null;
        this.nextId = 0;
        console.log('[è¿½è·¡] ãƒªã‚»ãƒƒãƒˆå®Œäº†');
    }
};

// ç”»åƒå‡¦ç†ãƒ»é€ä¿¡æ©Ÿèƒ½
const imageModule = {
    async sendFrame() {
        if (appState.isSending || !elements.video.videoWidth || !elements.video.videoHeight) return;
        
        appState.isSending = true;
        
        try {
            if (!browserDetectionModule.modelLoaded) {
                appState.isSending = false;
                return;
            }

            const detections = await browserDetectionModule.detectObjects(elements.video);
            
            elements.displayCanvas.width = elements.video.videoWidth;
            elements.displayCanvas.height = elements.video.videoHeight;
            
            const ctx = elements.displayCanvas.getContext('2d');
            ctx.drawImage(elements.video, 0, 0);
            
            if (detections.length > 0) {
                browserDetectionModule.drawDetections(elements.displayCanvas, detections);
                
                // ğŸ”¥ æœ€ã‚‚å…ƒæ°—ãªãƒ¡ãƒ€ã‚«ã®å…ƒæ°—åº¦ã‚’å–å¾—
                const vitality = medakaVitalityModule.update(detections);
                
                // ç”»é¢ã«å…ƒæ°—åº¦ã‚’è¡¨ç¤º
                this.drawVitalityInfo(ctx, vitality);
                
                // ğŸ”¥ ãƒ‡ãƒ¼ã‚¿ãŒååˆ†æºœã¾ã£ãŸã‚‰ã‚µãƒ¼ãƒãƒ¼é€ä¿¡
                if (vitality.dataPoints >= 30) {
                    await medakaVitalityModule.sendVitalityToServer(vitality);
                }
            } else {
                // æ¤œå‡ºãŒãªã„å ´åˆã‚‚å…ƒæ°—åº¦è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’ã‚¯ãƒªã‚¢/è¡¨ç¤º
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 10, 220, 80);
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.fillText('ãƒ¡ãƒ€ã‚«ã‚’æ¢ã—ã¦ã„ã¾ã™...', 20, 50);
            }
            
            if (appState.isFullscreen && appState.showingAnalysis) {
                this.updateFullscreenWithCanvas();
            }
            
        } catch (error) {
            console.error("æ¤œå‡ºã‚¨ãƒ©ãƒ¼:", error);
        } finally {
            appState.isSending = false;
        }
    },
    
    /**
     * ğŸ”¥ Canvasä¸Šã«å…ƒæ°—åº¦æƒ…å ±ã‚’æç”»ï¼ˆä¿®æ­£ç‰ˆï¼‰
     */
    drawVitalityInfo(ctx, vitality) {
        const padding = 10;
        const boxWidth = 220;
        const boxHeight = 100;
        
        // åŠé€æ˜ã®èƒŒæ™¯
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(padding, padding, boxWidth, boxHeight);
        
        // å…ƒæ°—åº¦ãƒ†ã‚­ã‚¹ãƒˆ
        ctx.fillStyle = vitality.color;
        ctx.font = 'bold 20px Arial';
        ctx.fillText(`å…ƒæ°—åº¦: ${vitality.score}`, padding + 10, padding + 30);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '16px Arial';
        ctx.fillText(`çŠ¶æ…‹: ${vitality.statusJa}`, padding + 10, padding + 55);
        ctx.fillText(`é€Ÿåº¦: ${vitality.avgSpeed} px/s`, padding + 10, padding + 75);
        
        // ğŸ”¥ è¿½è·¡æƒ…å ±ã‚’è¡¨ç¤º
        if (vitality.medakaId !== null) {
            ctx.fillText(`ğŸŸ ãƒ¡ãƒ€ã‚«ID: ${vitality.medakaId}`, padding + 10, padding + 95);
        }
        
        // ğŸ”¥ å³ä¸Šã«è¿½è·¡ä¸­ã®ãƒ¡ãƒ€ã‚«æ•°ã‚’è¡¨ç¤º
        if (vitality.trackedCount > 0) {
            const countText = `è¿½è·¡ä¸­: ${vitality.trackedCount}åŒ¹`;
            ctx.font = '14px Arial';
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(elements.displayCanvas.width - 120, 10, 110, 30);
            ctx.fillStyle = '#000000';
            ctx.fillText(countText, elements.displayCanvas.width - 110, 30);
        }
    },
    
    /**
     * ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³è¡¨ç¤ºæ™‚ã«Canvasã‚’æ›´æ–°
     */
    updateFullscreenWithCanvas() {
        if (!appState.isFullscreen) return;
        
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        elements.fullscreenCanvas.width = screenWidth;
        elements.fullscreenCanvas.height = screenHeight;
        
        fullscreenCtx.imageSmoothingEnabled = true;
        fullscreenCtx.imageSmoothingQuality = 'high';
        
        const canvasAspectRatio = elements.displayCanvas.width / elements.displayCanvas.height;
        const screenAspectRatio = screenWidth / screenHeight;
        
        let drawWidth, drawHeight, drawX, drawY;
        
        if (canvasAspectRatio > screenAspectRatio) {
            drawWidth = screenWidth;
            drawHeight = screenWidth / canvasAspectRatio;
            drawX = 0;
            drawY = (screenHeight - drawHeight) / 2;
        } else {
            drawWidth = screenHeight * canvasAspectRatio;
            drawHeight = screenHeight;
            drawX = (screenWidth - drawWidth) / 2;
            drawY = 0;
        }
        
        fullscreenCtx.clearRect(0, 0, screenWidth, screenHeight);
        fullscreenCtx.drawImage(elements.displayCanvas, drawX, drawY, drawWidth, drawHeight);
    }
};

// VADéŸ³å£°èªè­˜æ©Ÿèƒ½
const speechModule = {
    mediaRecorder: null,
    audioChunks: [],
    audioContext: null,
    analyser: null,
    silenceTimeout: null,
    stream: null,
    isListening: false,
    vadPaused: false,  // ğŸ†• VADä¸€æ™‚åœæ­¢ãƒ•ãƒ©ã‚°
    
    // VADè¨­å®š
    SILENCE_THRESHOLD: 0.08,      // ç„¡éŸ³åˆ¤å®šã®é–¾å€¤ï¼ˆ0.015 â†’ 0.08ï¼‰
    SILENCE_DURATION: 800,       // ç„¡éŸ³ãŒç¶šã„ãŸã‚‰åœæ­¢ï¼ˆãƒŸãƒªç§’ï¼‰
    VOICE_THRESHOLD: 10,        // éŸ³å£°æ¤œå‡ºã®é–¾å€¤ï¼ˆ0.035 â†’ 0.10ï¼‰
    MIN_RECORDING_TIME: 500,      // æœ€ä½éŒ²éŸ³æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
    recordingStartTime: null,

    init() {
        console.log('[éŸ³å£°] Whisper API + VAD ãƒ¢ãƒ¼ãƒ‰ã§åˆæœŸåŒ–');
    },

    async startListening() {
        if (this.isListening) return;
        
        try {
            const sessionResponse = await fetch(`${CONFIG.SERVER_URL}/check_session_status`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ profile_id: CONFIG.PROFILE_ID })
            });
            
            const sessionData = await sessionResponse.json();
            
            if (sessionData.has_active_session) {
                console.log("[éŸ³å£°å¾…æ©Ÿ] 2å›ç›®ãƒ•ãƒ­ãƒ¼ - éŸ³å£°æ¤œå‡ºå¾…æ©Ÿé–‹å§‹");
                await this.startVoiceDetection();
            } else if (sessionData.proactive_enabled) {
                console.log("[éŸ³å£°å¾…æ©Ÿ] 1å›ç›®ãƒ•ãƒ­ãƒ¼ - ãƒ¡ãƒ€ã‚«ã‹ã‚‰è©±ã—ã‹ã‘");
                await this.startWithMedakaGreeting();
            } else {
                console.log("[éŸ³å£°å¾…æ©Ÿ] 1å›ç›®ãƒ•ãƒ­ãƒ¼ - éŸ³å£°æ¤œå‡ºå¾…æ©Ÿé–‹å§‹");
                await this.startVoiceDetection();
            }
        } catch (error) {
            console.error("ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ç¢ºèªã‚¨ãƒ©ãƒ¼:", error);
            await this.startVoiceDetection();
        }
    },
  
async startVoiceDetection() {
        if (this.isListening) return;
        
        try {
            this.stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                channelCount: 1,           // ãƒ¢ãƒãƒ©ãƒ«
                sampleRate: 16000          // ğŸ”¥ 16kHzï¼ˆWhisperæ¨å¥¨ï¼‰
            }});
            
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048;
            
            const source = this.audioContext.createMediaStreamSource(this.stream);
            source.connect(this.analyser);
            
            this.isListening = true;
            this.vadPaused = false;  // ğŸ†• åˆæœŸåŒ–
            elements.statusDiv.textContent = "ğŸ¤ è©±ã—ã‹ã‘ã¦ãã ã•ã„...";
            elements.statusDiv.classList.remove('recording');
            this.monitorVoiceLevel();
            
        } catch (error) {
            console.error("éŸ³å£°æ¤œå‡ºé–‹å§‹ã‚¨ãƒ©ãƒ¼:", error);
            elements.statusDiv.textContent = "âš ï¸ ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ";
        }
    },

    monitorVoiceLevel() {
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const checkVoice = () => {
            if (!this.isListening) return;
            
            this.analyser.getByteTimeDomainData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                const normalized = (dataArray[i] - 128) / 128;
                sum += normalized * normalized;
            }
            const rms = Math.sqrt(sum / bufferLength);
            
            if (!appState.isRecording && rms > this.VOICE_THRESHOLD) {
                console.log('[VAD] éŸ³å£°æ¤œå‡º! ãƒ¬ãƒ™ãƒ«:', rms.toFixed(4));
                this.startDirectRecording();
            }
            
            if (appState.isRecording) {
                if (rms < this.SILENCE_THRESHOLD) {
                    if (!this.silenceTimeout) {
                        this.silenceTimeout = setTimeout(() => {
                            const recordingDuration = Date.now() - this.recordingStartTime;
                            if (recordingDuration >= this.MIN_RECORDING_TIME) {
                                this.stopRecording();
                            }
                        }, this.SILENCE_DURATION);
                    }
                } else {
                    if (this.silenceTimeout) {
                        clearTimeout(this.silenceTimeout);
                        this.silenceTimeout = null;
                    }
                }
            }
            
            requestAnimationFrame(checkVoice);
        };
        
        checkVoice();
    },

    async startDirectRecording() {
        if (appState.isRecording) return;
        
        // ğŸ”’ VADãŒä¸€æ™‚åœæ­¢ä¸­ã¯éŒ²éŸ³é–‹å§‹ã—ãªã„
        if (this.vadPaused) {
            return;
        }
        
        try {
            this.recordingStartTime = Date.now();
            
            this.mediaRecorder = new MediaRecorder(this.stream, {
                mimeType: 'audio/webm'
            });
            
            this.audioChunks = [];
            
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.audioChunks.push(event.data);
                }
            };
            
            this.mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                await this.sendAudioToServer(audioBlob);
            };
            
            this.mediaRecorder.start();
            appState.isRecording = true;
            elements.statusDiv.textContent = "ğŸ¤ èã„ã¦ã„ã¾ã™...";
            elements.statusDiv.classList.add('recording');
            
            console.log('[éŒ²éŸ³] é–‹å§‹');
            
        } catch (error) {
            console.error("éŒ²éŸ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:", error);
            elements.statusDiv.textContent = "âš ï¸ éŒ²éŸ³é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ";
        }
    },

    stopRecording() {
        if (this.silenceTimeout) {
            clearTimeout(this.silenceTimeout);
            this.silenceTimeout = null;
        }
         
        if (this.mediaRecorder && appState.isRecording) {
            this.mediaRecorder.stop();
            appState.isRecording = false;
            elements.statusDiv.classList.remove('recording');
            elements.statusDiv.textContent = "ğŸ”„ å‡¦ç†ä¸­...";
            
            // ğŸ”’ éŒ²éŸ³åœæ­¢ã—ãŸã‚‰ä¸€æ™‚çš„ã«VADã‚’åœæ­¢
            this.pauseVAD();
        }
    },

    pauseVAD() {
        // VADç›£è¦–ã‚’ä¸€æ™‚åœæ­¢ï¼ˆisListeningã¯trueã®ã¾ã¾ã€éŸ³å£°æ¤œå‡ºã ã‘ç„¡åŠ¹åŒ–ï¼‰
        this.vadPaused = true;
    },

    resumeVAD() {
        // VADç›£è¦–ã‚’å†é–‹
        this.vadPaused = false;
    },

    stopListening() {
        this.isListening = false;
        this.vadPaused = false;
        
        if (this.silenceTimeout) {
            clearTimeout(this.silenceTimeout);
            this.silenceTimeout = null;
        }
        
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        
        if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
        }
        
        elements.statusDiv.textContent = "â¹ï¸ éŸ³å£°æ¤œå‡ºåœæ­¢";
        elements.statusDiv.classList.remove('recording');
    },

async sendAudioToServer(audioBlob) {
    const t_start = performance.now();
    console.log('[â±ï¸ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] ãƒªã‚¯ã‚¨ã‚¹ãƒˆé–‹å§‹');
    
    try {
        elements.statusDiv.textContent = "ğŸ”„ éŸ³å£°ã‚’èªè­˜ã—ã¦ã„ã¾ã™...";
        
        const formData = new FormData();
        formData.append('file', audioBlob, 'recording.webm');
        
        const t_request_start = performance.now();
        const response = await fetch(`${CONFIG.SERVER_URL}/talk_with_fish_text`, {
            method: "POST",
            body: formData
        });
        const t_request_end = performance.now();
        console.log(`[â±ï¸ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] ã‚µãƒ¼ãƒãƒ¼å¿œç­”å—ä¿¡: ${((t_request_end - t_request_start) / 1000).toFixed(2)}ç§’`);
        
        if (!response.ok) {
            throw new Error('ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼');
        }
        
        const t_blob_start = performance.now();
        const audioResponseBlob = await response.blob();
        const t_blob_end = performance.now();
        console.log(`[â±ï¸ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] ãƒ‡ãƒ¼ã‚¿å—ä¿¡å®Œäº†: ${((t_blob_end - t_blob_start) / 1000).toFixed(2)}ç§’`);
        console.log(`[â±ï¸ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ${(audioResponseBlob.size / 1024).toFixed(2)}KB`);
        
        const audioUrl = URL.createObjectURL(audioResponseBlob);
        
        elements.statusDiv.textContent = "ğŸŸ ãƒ¡ãƒ€ã‚«ãŒè©±ã—ã¦ã„ã¾ã™...";
        
        const t_play_start = performance.now();
        elements.replyAudio.src = audioUrl;
        
        elements.replyAudio.onloadeddata = () => {
            const t_loaded = performance.now();
            console.log(`[â±ï¸ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] éŸ³å£°ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†: ${((t_loaded - t_play_start) / 1000).toFixed(2)}ç§’`);
        };
        
        elements.replyAudio.onplay = () => {
            const t_play = performance.now();
            console.log(`[â±ï¸ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] å†ç”Ÿé–‹å§‹: ${((t_play - t_play_start) / 1000).toFixed(2)}ç§’`);
            
            const t_total = (t_play - t_start) / 1000;
            console.log(`[â±ï¸ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] ğŸ¯ ç·åˆæ™‚é–“ï¼ˆéŒ²éŸ³åœæ­¢â†’å†ç”Ÿé–‹å§‹ï¼‰: ${t_total.toFixed(2)}ç§’`);
        };
            
            await elements.replyAudio.play();
            console.log('[ãƒ¡ãƒ€ã‚«å¿œç­”] play()å®Ÿè¡Œå®Œäº†');
            
            // ğŸ§ ãƒ¡ãƒ€ã‚«ã®éŸ³å£°ãŒçµ‚ã‚ã£ãŸã‚‰VADã‚’å†é–‹
            elements.replyAudio.onended = () => {
                console.log('[ãƒ¡ãƒ€ã‚«å¿œç­”] éŸ³å£°å†ç”Ÿçµ‚äº†');
                elements.statusDiv.textContent = "ğŸ¤ è©±ã—ã‹ã‘ã¦ãã ã•ã„...";
                appState.shouldRestart = true;
                
                // âœ… ãƒ¡ãƒ€ã‚«ãŒè©±ã—çµ‚ã‚ã£ãŸã®ã§VADã‚’å†é–‹
                if (this.isListening) {
                    this.resumeVAD();
                    console.log('[ä¼šè©±] ãƒ¡ãƒ€ã‚«ã®å¿œç­”å®Œäº† - æ¬¡ã®éŸ³å£°ã‚’å¾…æ©Ÿ');
                }
            };
            
        } catch (error) {
            console.error("éŸ³å£°é€ä¿¡ã‚¨ãƒ©ãƒ¼:", error);
            elements.statusDiv.textContent = 'âš ï¸ éŸ³å£°å‡¦ç†ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
            appState.shouldRestart = true;
            
            // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚VADã‚’å†é–‹
            setTimeout(() => {
                if (appState.shouldRestart && this.isListening) {
                    this.resumeVAD();
                    elements.statusDiv.textContent = "ğŸ¤ è©±ã—ã‹ã‘ã¦ãã ã•ã„...";
                    console.log('[ã‚¨ãƒ©ãƒ¼å¾©å¸°] VADå†é–‹');
                }
            }, 2000);
        }
    },

    async startWithMedakaGreeting() {
        try {
            elements.statusDiv.textContent = "ğŸŸ ãƒ¡ãƒ€ã‚«ãŒè©±ã—ã‹ã‘ã¦ã„ã¾ã™...";
            
            const greetingResponse = await fetch(`${CONFIG.SERVER_URL}/get_proactive_message`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ profile_id: CONFIG.PROFILE_ID })
            });
            
            const greetingBlob = await greetingResponse.blob();
            const greetingUrl = URL.createObjectURL(greetingBlob);
            elements.replyAudio.src = greetingUrl;
            
            await elements.replyAudio.play();
            
            elements.replyAudio.onended = () => {
                elements.statusDiv.textContent = "ğŸ¤ ãƒ¡ãƒ€ã‚«ãŒè©±ã—ã‹ã‘ãŸã‚ˆã€‚ãŠè¿”äº‹ã—ã¦ã­ï¼";
                setTimeout(() => {
                    this.startVoiceDetection();
                }, 1000);
            };
            
        } catch (error) {
            console.error("ãƒ¡ãƒ€ã‚«æŒ¨æ‹¶ã‚¨ãƒ©ãƒ¼:", error);
            this.startVoiceDetection();
        }
    }
};

// ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³æ©Ÿèƒ½
const fullscreenModule = {
    enterFullscreen() {
        appState.isFullscreen = true;
        elements.fullscreenContainer.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        elements.canvasFullscreenBtn.textContent = 'ğŸ“± æˆ»ã‚‹';
        
        if (appState.showingAnalysis && appState.currentImageData) {
            this.updateFullscreenCanvas(appState.currentImageData);
        } else {
            this.displayVideoInFullscreen();
        }
    },

    exitFullscreen() {
        appState.isFullscreen = false;
        elements.fullscreenContainer.classList.add('hidden');
        document.body.style.overflow = 'auto';
        elements.canvasFullscreenBtn.textContent = 'ğŸ” æ‹¡å¤§';
        
        if (this.videoRenderInterval) {
            clearInterval(this.videoRenderInterval);
            this.videoRenderInterval = null;
        }
    },

    displayVideoInFullscreen() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        elements.fullscreenCanvas.width = screenWidth;
        elements.fullscreenCanvas.height = screenHeight;
        elements.fullscreenCanvas.style.width = `${screenWidth}px`;
        elements.fullscreenCanvas.style.height = `${screenHeight}px`;
        
        fullscreenCtx.imageSmoothingEnabled = true;
        fullscreenCtx.imageSmoothingQuality = 'high';
        
        const renderVideo = () => {
            if (!appState.isFullscreen) return;
            
            const videoWidth = elements.video.videoWidth;
            const videoHeight = elements.video.videoHeight;
            
            if (videoWidth && videoHeight) {
                const imageAspectRatio = videoWidth / videoHeight;
                const screenAspectRatio = screenWidth / screenHeight;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageAspectRatio > screenAspectRatio) {
                    drawWidth = screenWidth;
                    drawHeight = screenWidth / imageAspectRatio;
                    drawX = 0;
                    drawY = (screenHeight - drawHeight) / 2;
                } else {
                    drawWidth = screenHeight * imageAspectRatio;
                    drawHeight = screenHeight;
                    drawX = (screenWidth - drawWidth) / 2;
                    drawY = 0;
                }
                
                fullscreenCtx.clearRect(0, 0, screenWidth, screenHeight);
                fullscreenCtx.drawImage(elements.video, drawX, drawY, drawWidth, drawHeight);
            }
        };
        
        if (this.videoRenderInterval) {
            clearInterval(this.videoRenderInterval);
        }
        this.videoRenderInterval = setInterval(renderVideo, 33);
        renderVideo();
    },

    updateFullscreenCanvas(resultImg) {
        if (!appState.isFullscreen) return;
        
        if (this.videoRenderInterval) {
            clearInterval(this.videoRenderInterval);
            this.videoRenderInterval = null;
        }
        
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        elements.fullscreenCanvas.width = screenWidth;
        elements.fullscreenCanvas.height = screenHeight;
        elements.fullscreenCanvas.style.width = `${screenWidth}px`;
        elements.fullscreenCanvas.style.height = `${screenHeight}px`;
        
        fullscreenCtx.imageSmoothingEnabled = true;
        fullscreenCtx.imageSmoothingQuality = 'high';
        
        const imageAspectRatio = resultImg.naturalWidth / resultImg.naturalHeight;
        const screenAspectRatio = screenWidth / screenHeight;
        
        let drawWidth, drawHeight, drawX, drawY;
        
        if (imageAspectRatio > screenAspectRatio) {
            drawWidth = screenWidth;
            drawHeight = screenWidth / imageAspectRatio;
            drawX = 0;
            drawY = (screenHeight - drawHeight) / 2;
        } else {
            drawWidth = screenHeight * imageAspectRatio;
            drawHeight = screenHeight;
            drawX = (screenWidth - drawWidth) / 2;
            drawY = 0;
        }
        
        fullscreenCtx.clearRect(0, 0, screenWidth, screenHeight);
        fullscreenCtx.drawImage(resultImg, drawX, drawY, drawWidth, drawHeight);
    },

    setupEventListeners() {
        elements.canvasFullscreenBtn.addEventListener('click', () => {
            if (appState.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        });

        elements.displayCanvas.addEventListener('click', () => {
            if (!appState.isFullscreen) {
                if (appState.showingAnalysis) {
                    this.enterFullscreen();
                }
            }
        });

        elements.exitBtn.addEventListener('click', () => this.exitFullscreen());
    }
};

// UIåˆ¶å¾¡æ©Ÿèƒ½
const uiModule = {
    setupVADButtons() {
        elements.vadStartBtn.addEventListener('click', () => {
            speechModule.startListening();
            elements.vadStartBtn.disabled = true;
            elements.vadStopBtn.disabled = false;
        });
        
        elements.vadStopBtn.addEventListener('click', () => {
            speechModule.stopListening();
            elements.vadStartBtn.disabled = false;
            elements.vadStopBtn.disabled = true;
        });
    },
    
    setupStartButton() {
        elements.startButton.addEventListener("click", () => {
            elements.replyAudio.src = "";
            elements.replyAudio.load();
            setTimeout(() => {
                appState.shouldRestart = true;
                elements.startButton.classList.add('hidden');
                elements.vadControls.classList.remove('hidden');
                elements.statusDiv.textContent = "ğŸ¤ ã€ŒéŸ³å£°æ¤œå‡ºé–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„";
                
                // åˆæœŸçŠ¶æ…‹ã®è¨­å®š
                elements.vadStartBtn.disabled = false;
                elements.vadStopBtn.disabled = true;
            }, 500);
        });
    },
    
    setupSwitchButton() {
        elements.switchViewBtn.addEventListener('click', () => {
            appState.showingAnalysis = !appState.showingAnalysis;
            
            if (appState.showingAnalysis) {
                elements.displayCanvas.classList.remove('hidden');
                elements.switchViewBtn.textContent = 'ğŸ“¹ ã‚«ãƒ¡ãƒ©';
            } else {
                elements.displayCanvas.classList.add('hidden');
                elements.switchViewBtn.textContent = 'ğŸ“Š è§£æçµæœ';
            }
        });
    }
};

// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–ãƒ»ãƒ¡ã‚¤ãƒ³å‡¦ç†
const app = {
    async init() {
        
        elements.vadControls.classList.add('hidden');
        await this.loadProfiles();  
        // âœ… ãƒ–ãƒ©ã‚¦ã‚¶æ¤œå‡ºãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿
        await browserDetectionModule.loadModel();
        
        await cameraModule.startCamera();
        speechModule.init();
        fullscreenModule.setupEventListeners();
        uiModule.setupVADButtons();
        uiModule.setupStartButton();
        uiModule.setupSwitchButton();
        
        setInterval(() => imageModule.sendFrame(), CONFIG.FRAME_RATE);
        
        this.optimizeTouchEvents();
        
        console.log('ğŸ  é­šèªè­˜ã‚¢ãƒ—ãƒªãŒåˆæœŸåŒ–ã•ã‚Œã¾ã—ãŸ (ãƒ–ãƒ©ã‚¦ã‚¶æ¤œå‡º)');
    },
    
async loadProfiles() {
    try {
        const res = await fetch(`${CONFIG.SERVER_URL}/profiles`);
        const profiles = await res.json();
        
        const select = document.getElementById('profileSelect');
        select.innerHTML = '<option value="">ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠ...</option>';
        
        profiles.forEach(p => {
            const option = document.createElement('option');
            option.value = p.id;
            option.textContent = `${p.name} (${p.age}æ­³)`;
            select.appendChild(option);
        });
        
        // ğŸ”¥ æœ€åˆã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’è‡ªå‹•é¸æŠ
        if (profiles.length > 0) {
            select.value = profiles[0].id;
            CONFIG.PROFILE_ID = profiles[0].id;
            
            await fetch(`${CONFIG.SERVER_URL}/set_current_profile`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({profile_id: profiles[0].id})
            });
            
            elements.statusDiv.textContent = `ğŸ‘¤ ${profiles[0].name}ã•ã‚“ã‚’é¸æŠä¸­`;
            console.log('âœ… åˆæœŸé¸æŠ:', profiles[0].name, 'ID:', profiles[0].id);
        }
        
        // ğŸ”¥ ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ä¸€åº¦ã ã‘ç™»éŒ²ï¼ˆæ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼‰
        const newSelect = select.cloneNode(true);
        select.parentNode.replaceChild(newSelect, select);
        
        newSelect.addEventListener('change', async (e) => {
            const profileId = parseInt(e.target.value);
            if (!profileId) return;
            
            appState.currentProfileId = profileId;
            CONFIG.PROFILE_ID = profileId;
            
            console.log('ğŸ“¡ ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡:', profileId);
            
            const response = await fetch(`${CONFIG.SERVER_URL}/set_current_profile`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({profile_id: profileId})
            });
            
            const result = await response.json();
            console.log('âœ… ã‚µãƒ¼ãƒãƒ¼å¿œç­”:', result);
            
            const selectedText = e.target.options[e.target.selectedIndex].text;
            elements.statusDiv.textContent = `ğŸ‘¤ ${selectedText} ã‚’é¸æŠä¸­`;
        });
        
        // æ–°è¦ä½œæˆãƒœã‚¿ãƒ³ï¼ˆã“ã¡ã‚‰ã‚‚å†ç™»éŒ²ï¼‰
        const addBtn = document.getElementById('addAccountBtn');
        const newAddBtn = addBtn.cloneNode(true);
        addBtn.parentNode.replaceChild(newAddBtn, addBtn);
        
        newAddBtn.addEventListener('click', async () => {
            const name = prompt('åå‰ã‚’å…¥åŠ›:');
            if (!name) return;
            
            const age = prompt('å¹´é½¢ã‚’å…¥åŠ›:');
            if (!age || isNaN(age)) {
                alert('å¹´é½¢ã¯æ•°å­—ã§å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            const res = await fetch(`${CONFIG.SERVER_URL}/profiles`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({name, age: parseInt(age)})
            });
            
            if (res.ok) {
                alert('âœ… ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ');
                await this.loadProfiles();
            }
        });
        
        console.log(`âœ… ${profiles.length}ä»¶ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆèª­ã¿è¾¼ã¿å®Œäº†`);
        
    } catch (error) {
        console.error('âŒ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
    }
},
  
    optimizeTouchEvents() {
        document.addEventListener('touchstart', function(){}, {passive: true});
        document.addEventListener('touchmove', function(){}, {passive: true});
    }
};
app.init();
  </script>
</body>
</html>